{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Curso de MicroPython En esta pagina encontraras los contenidos para poder instalar y utilizar MicroPython en las placas programables ESP32 y Raspberry Pi Pico (W). Contenidos Instalar Entorno Dispositivos Instalacion MicroPython Simulador MicroPython Primeros Pasos Entrada/Salida Digital Entrada/Salida Analogica Interrupciones Sensores/Actuadores Redes Comunicaci\u00f3n Http) MQTT Ejercicios Finales Recursos Versiones versi\u00f3n 1.2 - Diciembre 2025 (Se a\u00f1aden nuevos apartados y ejemplos) versi\u00f3n 1.1 - Mayo 2023 (actualizaci\u00f3n de contenidos y correcci\u00f3n de errores) versi\u00f3n 1.0 - Octubre 2023 (versi\u00f3n inicial)","title":"Home"},{"location":"#curso-de-micropython","text":"En esta pagina encontraras los contenidos para poder instalar y utilizar MicroPython en las placas programables ESP32 y Raspberry Pi Pico (W).","title":"Curso de MicroPython"},{"location":"#contenidos","text":"Instalar Entorno Dispositivos Instalacion MicroPython Simulador MicroPython Primeros Pasos Entrada/Salida Digital Entrada/Salida Analogica Interrupciones Sensores/Actuadores Redes Comunicaci\u00f3n Http) MQTT Ejercicios Finales Recursos","title":"Contenidos"},{"location":"#versiones","text":"versi\u00f3n 1.2 - Diciembre 2025 (Se a\u00f1aden nuevos apartados y ejemplos) versi\u00f3n 1.1 - Mayo 2023 (actualizaci\u00f3n de contenidos y correcci\u00f3n de errores) versi\u00f3n 1.0 - Octubre 2023 (versi\u00f3n inicial)","title":"Versiones"},{"location":"analog_io/","text":"Entrada/Salida Anal\u00f3gica Nuestro dispositivo tambi\u00e9n cuenta con capacidades de entrada y salida anal\u00f3gica, lo que permite una interacci\u00f3n m\u00e1s precisa con sensores y actuadores que operan en un rango continuo de valores. Las Entradas o Salidas Anal\u00f3gicas (E/S anal\u00f3gicas) permiten al dispositivo leer se\u00f1ales anal\u00f3gicas de sensores o enviar se\u00f1ales anal\u00f3gicas a actuadores. Estas E/S anal\u00f3gicas son esenciales para aplicaciones que requieren mediciones precisas, como la lectura de sensores de temperatura, luz, humedad, entre otros. Configuraci\u00f3n de E/S Anal\u00f3gicas Para configurar un pin como entrada o salida anal\u00f3gica, utilizamos las clases ADC (Convertidor Anal\u00f3gico a Digital) y DAC (Convertidor Digital a Anal\u00f3gico) del m\u00f3dulo machine . Aqu\u00ed hay un ejemplo de c\u00f3mo configurar un pin: from machine import ADC, DAC # Configurar un pin como entrada anal\u00f3gica adc = ADC(pin_number) # Configurar un pin como salida anal\u00f3gica dac = DAC(pin_number) Donde pin_number es el n\u00famero del pin que deseas configurar. Lectura de Entradas Anal\u00f3gicas Los valores anal\u00f3gicos se obtienen a partir de convertir diferentes niveles de voltaje en calores digitales gracias al uso de los DAC y ADC. Estos convierten las se\u00f1ales anal\u00f3gicas en valores digitales que el microcontrolador puede procesar. Es importante ver el pinout de cada dispositivo ya que por ejemplo para el ESP32 los pines ADC son: 32, 33, 34, 35, 36, 39, mientras que para la Raspberry Pi Pico son: 26, 27, 28. Para leer el valor de un pin configurado como entrada anal\u00f3gica, utilizaremos el m\u00e9todo read() de la clase ADC : from machine import ADC adc = ADC(pin_number) value = adc.read() El valor devuelto por read() ser\u00e1 un n\u00famero entero que representa el nivel de voltaje en el pin, generalmente en un rango de 0 a 4095 (12 bits) o 0 a 1023 (10 bits), dependiendo del dispositivo. Tanto Para el ESP32 como la Raspberry Pi pico, tiene un ADC de 12 bits, por lo que el valor devuelto estar\u00e1 en el rango de 0 a 4095. Veamos un ejemplo. Ejemplo: Lectura de un Potenci\u00f3metro Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 Potenci\u00f3metro (10KOhmios recomendado) Cables de conexi\u00f3n Protoboard El montaje que realizaremos ser\u00e1 el siguiente: Por \u00faltimo, el c\u00f3digo para leer el valor del potenci\u00f3metro y mostrarlo en la consola es el siguiente: from machine import ADC import time pin_number = 32 # Configurar el pin ADC adc = ADC(pin_number) while True: # Leer el valor anal\u00f3gico value = adc.read() print(\"Valor del potenci\u00f3metro:\", value) time.sleep(1) En este ejemplo, el valor le\u00eddo del potenci\u00f3metro se imprimir\u00e1 en la consola cada segundo. A medida que gires el potenci\u00f3metro, el valor cambiar\u00e1, reflejando el nivel de voltaje en el pin anal\u00f3gico. Ejemplo 2: Fotocelda (LDR) Una fotocelda o LDR (Light Dependent Resistor) es un tipo de resistor cuya resistencia var\u00eda en funci\u00f3n de la cantidad de luz que incide sobre \u00e9l. A medida que la luz aumenta, la resistencia disminuye, y viceversa. Para este ejemplo, necesitar\u00e1s los siguientes componentes: - 1 Fotocelda (LDR) - 1 Resistencia de 10K ohmios - Cables de conexi\u00f3n - Protoboard El montaje que realizaremos ser\u00e1 el siguiente: El siguiente c\u00f3digo lee el valor de la fotocelda y lo imprime en la consola: from machine import ADC import time pin_number = 33 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando adc = ADC(pin_number) while True: value = adc.read() print(\"Valor de la fotocelda (LDR):\", value) time.sleep(1) En este ejemplo, el valor le\u00eddo de la fotocelda se imprimir\u00e1 en la consola cada segundo. A medida que la cantidad de luz que incide sobre la LDR cambie, el valor tambi\u00e9n cambiar\u00e1, reflejando la variaci\u00f3n en la resistencia del sensor. Escritura de Salidas Anal\u00f3gicas Otro de los aspectos importantes del uso de E/S anal\u00f3gicas es la capacidad de generar se\u00f1ales anal\u00f3gicas para controlar actuadores como motores, servomotores, o incluso para generar se\u00f1ales de audio. Este proceso se realiza utilizando el llamado PWM (Modulaci\u00f3n por Ancho de Pulso) o mediante el uso de un DAC (Convertidor Digital a Anal\u00f3gico) si el dispositivo lo soporta. En el ESP32 y Raspberry Pi Pico, podemos utilizar la clase DAC para generar se\u00f1ales anal\u00f3gicas. Para escribir un valor en un pin configurado como salida anal\u00f3gica, utilizamos el m\u00e9todo write() de la clase DAC : from machine import DAC pin_number = 25 dac = DAC(pin_number) value = 128 # Valor anal\u00f3gico entre 0 y 255 dac.write(value) El DAC que se utiliza en estos dispositivos generalmente tiene una resoluci\u00f3n de 8 bits, por lo que el valor debe estar en el rango de 0 a 255. Es importante conocer que los pines disponibles para realizar el llamado PWM en ESP32 son: 25, 26, 27, 14, 12, 13, 15, 2, 4, 16, 17, 18, 19, 21, 22, 23. Mientras que en la Raspberry Pi Pico son: 0, 1, 2, 3, 4, 5, 6, 7. Ejemplo: Generaci\u00f3n de una Se\u00f1al Anal\u00f3gica Para este ejemplo, necesitaremos los siguientes componentes: 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard El montaje que realizaremos ser\u00e1 el siguiente: El siguiente c\u00f3digo genera una se\u00f1al anal\u00f3gica variable en el pin DAC, que puede ser utilizada para controlar la intensidad de un LED o cualquier otro actuador compatible: from machine import DAC import time pin_number = 12 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando dac = DAC(pin_number) while True: for value in range(0, 256, 5): # Incrementa el valor de 0 a 255 dac.write(value) time.sleep(0.05) for value in range(255, -1, -5): # Decrementa el valor de 255 a 0 dac.write(value) time.sleep(0.05) Con este programa, el valor anal\u00f3gico se incrementa y decrementa gradualmente, lo que puede hacer que un LED conectado al pin DAC var\u00ede su brillo de manera suave.","title":"Entrada/Salida Analogica"},{"location":"analog_io/#entradasalida-analogica","text":"Nuestro dispositivo tambi\u00e9n cuenta con capacidades de entrada y salida anal\u00f3gica, lo que permite una interacci\u00f3n m\u00e1s precisa con sensores y actuadores que operan en un rango continuo de valores. Las Entradas o Salidas Anal\u00f3gicas (E/S anal\u00f3gicas) permiten al dispositivo leer se\u00f1ales anal\u00f3gicas de sensores o enviar se\u00f1ales anal\u00f3gicas a actuadores. Estas E/S anal\u00f3gicas son esenciales para aplicaciones que requieren mediciones precisas, como la lectura de sensores de temperatura, luz, humedad, entre otros.","title":"Entrada/Salida Anal\u00f3gica"},{"location":"analog_io/#configuracion-de-es-analogicas","text":"Para configurar un pin como entrada o salida anal\u00f3gica, utilizamos las clases ADC (Convertidor Anal\u00f3gico a Digital) y DAC (Convertidor Digital a Anal\u00f3gico) del m\u00f3dulo machine . Aqu\u00ed hay un ejemplo de c\u00f3mo configurar un pin: from machine import ADC, DAC # Configurar un pin como entrada anal\u00f3gica adc = ADC(pin_number) # Configurar un pin como salida anal\u00f3gica dac = DAC(pin_number) Donde pin_number es el n\u00famero del pin que deseas configurar.","title":"Configuraci\u00f3n de E/S Anal\u00f3gicas"},{"location":"analog_io/#lectura-de-entradas-analogicas","text":"Los valores anal\u00f3gicos se obtienen a partir de convertir diferentes niveles de voltaje en calores digitales gracias al uso de los DAC y ADC. Estos convierten las se\u00f1ales anal\u00f3gicas en valores digitales que el microcontrolador puede procesar. Es importante ver el pinout de cada dispositivo ya que por ejemplo para el ESP32 los pines ADC son: 32, 33, 34, 35, 36, 39, mientras que para la Raspberry Pi Pico son: 26, 27, 28. Para leer el valor de un pin configurado como entrada anal\u00f3gica, utilizaremos el m\u00e9todo read() de la clase ADC : from machine import ADC adc = ADC(pin_number) value = adc.read() El valor devuelto por read() ser\u00e1 un n\u00famero entero que representa el nivel de voltaje en el pin, generalmente en un rango de 0 a 4095 (12 bits) o 0 a 1023 (10 bits), dependiendo del dispositivo. Tanto Para el ESP32 como la Raspberry Pi pico, tiene un ADC de 12 bits, por lo que el valor devuelto estar\u00e1 en el rango de 0 a 4095. Veamos un ejemplo.","title":"Lectura de Entradas Anal\u00f3gicas"},{"location":"analog_io/#ejemplo-lectura-de-un-potenciometro","text":"Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 Potenci\u00f3metro (10KOhmios recomendado) Cables de conexi\u00f3n Protoboard El montaje que realizaremos ser\u00e1 el siguiente: Por \u00faltimo, el c\u00f3digo para leer el valor del potenci\u00f3metro y mostrarlo en la consola es el siguiente: from machine import ADC import time pin_number = 32 # Configurar el pin ADC adc = ADC(pin_number) while True: # Leer el valor anal\u00f3gico value = adc.read() print(\"Valor del potenci\u00f3metro:\", value) time.sleep(1) En este ejemplo, el valor le\u00eddo del potenci\u00f3metro se imprimir\u00e1 en la consola cada segundo. A medida que gires el potenci\u00f3metro, el valor cambiar\u00e1, reflejando el nivel de voltaje en el pin anal\u00f3gico.","title":"Ejemplo: Lectura de un Potenci\u00f3metro"},{"location":"analog_io/#ejemplo-2-fotocelda-ldr","text":"Una fotocelda o LDR (Light Dependent Resistor) es un tipo de resistor cuya resistencia var\u00eda en funci\u00f3n de la cantidad de luz que incide sobre \u00e9l. A medida que la luz aumenta, la resistencia disminuye, y viceversa. Para este ejemplo, necesitar\u00e1s los siguientes componentes: - 1 Fotocelda (LDR) - 1 Resistencia de 10K ohmios - Cables de conexi\u00f3n - Protoboard El montaje que realizaremos ser\u00e1 el siguiente: El siguiente c\u00f3digo lee el valor de la fotocelda y lo imprime en la consola: from machine import ADC import time pin_number = 33 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando adc = ADC(pin_number) while True: value = adc.read() print(\"Valor de la fotocelda (LDR):\", value) time.sleep(1) En este ejemplo, el valor le\u00eddo de la fotocelda se imprimir\u00e1 en la consola cada segundo. A medida que la cantidad de luz que incide sobre la LDR cambie, el valor tambi\u00e9n cambiar\u00e1, reflejando la variaci\u00f3n en la resistencia del sensor.","title":"Ejemplo 2: Fotocelda (LDR)"},{"location":"analog_io/#escritura-de-salidas-analogicas","text":"Otro de los aspectos importantes del uso de E/S anal\u00f3gicas es la capacidad de generar se\u00f1ales anal\u00f3gicas para controlar actuadores como motores, servomotores, o incluso para generar se\u00f1ales de audio. Este proceso se realiza utilizando el llamado PWM (Modulaci\u00f3n por Ancho de Pulso) o mediante el uso de un DAC (Convertidor Digital a Anal\u00f3gico) si el dispositivo lo soporta. En el ESP32 y Raspberry Pi Pico, podemos utilizar la clase DAC para generar se\u00f1ales anal\u00f3gicas. Para escribir un valor en un pin configurado como salida anal\u00f3gica, utilizamos el m\u00e9todo write() de la clase DAC : from machine import DAC pin_number = 25 dac = DAC(pin_number) value = 128 # Valor anal\u00f3gico entre 0 y 255 dac.write(value) El DAC que se utiliza en estos dispositivos generalmente tiene una resoluci\u00f3n de 8 bits, por lo que el valor debe estar en el rango de 0 a 255. Es importante conocer que los pines disponibles para realizar el llamado PWM en ESP32 son: 25, 26, 27, 14, 12, 13, 15, 2, 4, 16, 17, 18, 19, 21, 22, 23. Mientras que en la Raspberry Pi Pico son: 0, 1, 2, 3, 4, 5, 6, 7.","title":"Escritura de Salidas Anal\u00f3gicas"},{"location":"analog_io/#ejemplo-generacion-de-una-senal-analogica","text":"Para este ejemplo, necesitaremos los siguientes componentes: 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard El montaje que realizaremos ser\u00e1 el siguiente: El siguiente c\u00f3digo genera una se\u00f1al anal\u00f3gica variable en el pin DAC, que puede ser utilizada para controlar la intensidad de un LED o cualquier otro actuador compatible: from machine import DAC import time pin_number = 12 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando dac = DAC(pin_number) while True: for value in range(0, 256, 5): # Incrementa el valor de 0 a 255 dac.write(value) time.sleep(0.05) for value in range(255, -1, -5): # Decrementa el valor de 255 a 0 dac.write(value) time.sleep(0.05) Con este programa, el valor anal\u00f3gico se incrementa y decrementa gradualmente, lo que puede hacer que un LED conectado al pin DAC var\u00ede su brillo de manera suave.","title":"Ejemplo: Generaci\u00f3n de una Se\u00f1al Anal\u00f3gica"},{"location":"devices/","text":"Dispositivos En este peque\u00f1o taller, vamos a centrarnos en dos dispositivos: ESP32 Raspberry Pi Pico Cada uno de estos microcontroladores, es compatible con MicroPython y con otros muchos lenguajes y herramientas. Ambos microcontroladores permiten ser programados en muchos lenguajes como puede ser C, Arduino, Node.js y por supuesto en MicroPython. Son muy sencillas de utilizar y tienen mucho soporte por la comunidad. Vamos a ver cada una de estas placas para conocer sus caracter\u00edsticas. ESP32 La ESP32, es un microcontrolador de espresiff, que es muy versatil y tiene mucha potencia comparado con otros microcontroladores de la misma familia. Tiene soporte para muchos lenguajes, pero en este caso lo utilizaremos para MicroPython. Entre sus caracter\u00edsticas estan: CPU: microprocesador de 32 bits a doble nucleo operando a 160Mhz o 240Mhz. Memoria: 520KB de SRAM Conectividad inhal\u00e1mbrica: Wifi: 802.11 b/g/n Bluetooth: BLE y v4.2 Interfaces: 2x 8 bit DAC 4x SPI 3x UART 2x I2C 12 Bit ADC Puede encontrar m\u00e1s informaci\u00f3n sobre esta placa en: https://es.wikipedia.org/wiki/ESP32 Mostramos ademas el PInOut de la ESP-wROOm: Rasperry Pi Pico Raspberry Pi Pico, es una placa programable basado en el microcontrolador RP2040; dise\u00f1ado para esta placa. Permite ser programada por varios lenguajes y entre ellos micropython. Existen varias versiones de esta placa ya que algunas incluyen wifi y otras no. Las versiones que podemos encontrar son: Raspberry Pi Pico (H) Raspberry Pi Pico W (WH) con conexi\u00f3n inhal\u00e1mbrica. Las caracter\u00edsticas de esta placa son: Procesador Dual-core ARM Cortex M0+ hasta 133Mhz. 264KB de RAM y 2MB de memoria Flash USB 1.1 como dispositivo y como host 26 GPIO 2xSPI, 2x I2C, 2x UART 12 Bit ADC y 16 canales PWM. Conexi\u00f3n Wifi con soporte WPA3 (S\u00f3lo Raspberry Pi Pico) Puedes encontrar m\u00e1s informaci\u00f3n sobre Raspberry Pi Pico en su p\u00e1gina oficial: Raspberry Pi Pico Dejamos adem\u00e1s, el Piout de una raspberry Pi Pico Raspberry Pi Pico Raspberry Pi Pico W","title":"Dispositivos"},{"location":"devices/#dispositivos","text":"En este peque\u00f1o taller, vamos a centrarnos en dos dispositivos: ESP32 Raspberry Pi Pico Cada uno de estos microcontroladores, es compatible con MicroPython y con otros muchos lenguajes y herramientas. Ambos microcontroladores permiten ser programados en muchos lenguajes como puede ser C, Arduino, Node.js y por supuesto en MicroPython. Son muy sencillas de utilizar y tienen mucho soporte por la comunidad. Vamos a ver cada una de estas placas para conocer sus caracter\u00edsticas.","title":"Dispositivos"},{"location":"devices/#esp32","text":"La ESP32, es un microcontrolador de espresiff, que es muy versatil y tiene mucha potencia comparado con otros microcontroladores de la misma familia. Tiene soporte para muchos lenguajes, pero en este caso lo utilizaremos para MicroPython. Entre sus caracter\u00edsticas estan: CPU: microprocesador de 32 bits a doble nucleo operando a 160Mhz o 240Mhz. Memoria: 520KB de SRAM Conectividad inhal\u00e1mbrica: Wifi: 802.11 b/g/n Bluetooth: BLE y v4.2 Interfaces: 2x 8 bit DAC 4x SPI 3x UART 2x I2C 12 Bit ADC Puede encontrar m\u00e1s informaci\u00f3n sobre esta placa en: https://es.wikipedia.org/wiki/ESP32 Mostramos ademas el PInOut de la ESP-wROOm:","title":"ESP32"},{"location":"devices/#rasperry-pi-pico","text":"Raspberry Pi Pico, es una placa programable basado en el microcontrolador RP2040; dise\u00f1ado para esta placa. Permite ser programada por varios lenguajes y entre ellos micropython. Existen varias versiones de esta placa ya que algunas incluyen wifi y otras no. Las versiones que podemos encontrar son: Raspberry Pi Pico (H) Raspberry Pi Pico W (WH) con conexi\u00f3n inhal\u00e1mbrica. Las caracter\u00edsticas de esta placa son: Procesador Dual-core ARM Cortex M0+ hasta 133Mhz. 264KB de RAM y 2MB de memoria Flash USB 1.1 como dispositivo y como host 26 GPIO 2xSPI, 2x I2C, 2x UART 12 Bit ADC y 16 canales PWM. Conexi\u00f3n Wifi con soporte WPA3 (S\u00f3lo Raspberry Pi Pico) Puedes encontrar m\u00e1s informaci\u00f3n sobre Raspberry Pi Pico en su p\u00e1gina oficial: Raspberry Pi Pico Dejamos adem\u00e1s, el Piout de una raspberry Pi Pico Raspberry Pi Pico Raspberry Pi Pico W","title":"Rasperry Pi Pico"},{"location":"digital_io/","text":"Entrada/Salida Digital Vamos a ver una visi\u00f3n general de las capacidades de entrada y salida digital de nuestro dispositivo. Las Entradas o Salidas Digitales (E/S digitales) permiten al dispositivo interactuar con otros componentes electr\u00f3nicos, como sensores, actuadores y otros dispositivos digitales. Estas E/S digitales pueden configurarse como entradas para leer se\u00f1ales digitales o como salidas para enviar se\u00f1ales digitales. Configuraci\u00f3n de E/S Digitales Para configurar un pin como entrada o salida digital, utilizamos la clase Pin del m\u00f3dulo machine . Aqu\u00ed hay un ejemplo de c\u00f3mo configurar un pin: from machine import Pin # Configurar un pin como salida digital pin = Pin(pin_number, Pin.OUT) # Configurar un pin como entrada digital pin = Pin(pin_number, Pin.IN) Donde pin_number es el n\u00famero del pin que deseas configurar, y Pin.OUT y Pin.IN son constantes que indican si el pin se configura como salida o entrada, respectivamente. Lectura de Entradas Digitales Para leer el estado de un pin configurado como entrada digital, utilizaremos el m\u00e9todo value() de la clase Pin : from machine import Pin pin = Pin(pin_number, Pin.IN) state = pin.value() El valor devuelto por value() ser\u00e1 1 (alto) si el pin est\u00e1 en un estado alto (5V o 3.3V, dependiendo del dispositivo) o 0 (bajo) si est\u00e1 en un estado bajo (0V). Escritura de Salidas Digitales Para establecer el estado de un pin configurado como salida digital, utilizamos el m\u00e9todo value() de la clase Pin : from machine import Pin pin = Pin(pin_number, Pin.OUT) pin.value(1) # Establecer el pin en alto pin.value(0) # Establecer el pin en bajo A continuaci\u00f3n, vamos a realizar el montaje de un circuito simple para controlar un LED utilizando una salida digital. Ejemplo: Control de un LED Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 LED 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: Una vez montado, vamos a escribir un programa para hacer parpadear el LED. from machine import Pin import time pin_number = 17 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando led = Pin(pin_number, Pin.OUT) while True: led.value(1) # Encender el LED time.sleep(1) # Esperar 1 segundo led.value(0) # Apagar el LED time.sleep(1) # Esperar 1 segundo Este programa encender\u00e1 y apagar\u00e1 el LED cada segundo, demostrando el uso de una salida digital para controlar un dispositivo externo. Como vemos en el c\u00f3digo, utilizamos la funci\u00f3n time.sleep() para crear un retraso entre los cambios de estado del LED. Ahora, nos centraremos en la lectura de una entrada digital utilizando un bot\u00f3n. Para ello, vamos a utilizar el bot\u00f3n como nuevo componente. Un bot\u00f3n es un interruptor que, cuando se presiona, conecta el pin a tierra (0V). Para evitar que el pin quede \"flotando\" cuando el bot\u00f3n no est\u00e1 presionado, utilizaremos una resistencia pull-up interna. Ejemplo: Lectura de un Bot\u00f3n Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 Bot\u00f3n Cables de conexi\u00f3n Protoboard 1 Resistencia de 10k ohmios (si no usas la resistencia pull-up interna) 1 Resistencia de 220 ohmios (para el LED) 1 LED El montaje se realizar\u00e1 de la siguiente manera: Una vez montado, vamos a escribir un programa para leer el estado del bot\u00f3n y controlar el LED en consecuencia. from machine import Pin import time pin_button = 2 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando para el bot\u00f3n pin_led = 17 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando para el LED button = Pin(pin_button, Pin.IN) led = Pin(pin_led, Pin.OUT) while True: if button.value() == 1: # El bot\u00f3n est\u00e1 presionado led.value(1) # Encender el LED else: led.value(0) # Apagar el LED time.sleep(0.1) # Peque\u00f1o retraso para evitar rebotes En este programa, cuando el bot\u00f3n se presiona, el pin de entrada se conecta a tierra, y el LED se enciende. Cuando el bot\u00f3n no est\u00e1 presionado, el pin de entrada est\u00e1 en alto debido a la resistencia pull-up interna, y el LED se apaga.","title":"Entrada/Salida Digital"},{"location":"digital_io/#entradasalida-digital","text":"Vamos a ver una visi\u00f3n general de las capacidades de entrada y salida digital de nuestro dispositivo. Las Entradas o Salidas Digitales (E/S digitales) permiten al dispositivo interactuar con otros componentes electr\u00f3nicos, como sensores, actuadores y otros dispositivos digitales. Estas E/S digitales pueden configurarse como entradas para leer se\u00f1ales digitales o como salidas para enviar se\u00f1ales digitales.","title":"Entrada/Salida Digital"},{"location":"digital_io/#configuracion-de-es-digitales","text":"Para configurar un pin como entrada o salida digital, utilizamos la clase Pin del m\u00f3dulo machine . Aqu\u00ed hay un ejemplo de c\u00f3mo configurar un pin: from machine import Pin # Configurar un pin como salida digital pin = Pin(pin_number, Pin.OUT) # Configurar un pin como entrada digital pin = Pin(pin_number, Pin.IN) Donde pin_number es el n\u00famero del pin que deseas configurar, y Pin.OUT y Pin.IN son constantes que indican si el pin se configura como salida o entrada, respectivamente.","title":"Configuraci\u00f3n de E/S Digitales"},{"location":"digital_io/#lectura-de-entradas-digitales","text":"Para leer el estado de un pin configurado como entrada digital, utilizaremos el m\u00e9todo value() de la clase Pin : from machine import Pin pin = Pin(pin_number, Pin.IN) state = pin.value() El valor devuelto por value() ser\u00e1 1 (alto) si el pin est\u00e1 en un estado alto (5V o 3.3V, dependiendo del dispositivo) o 0 (bajo) si est\u00e1 en un estado bajo (0V).","title":"Lectura de Entradas Digitales"},{"location":"digital_io/#escritura-de-salidas-digitales","text":"Para establecer el estado de un pin configurado como salida digital, utilizamos el m\u00e9todo value() de la clase Pin : from machine import Pin pin = Pin(pin_number, Pin.OUT) pin.value(1) # Establecer el pin en alto pin.value(0) # Establecer el pin en bajo A continuaci\u00f3n, vamos a realizar el montaje de un circuito simple para controlar un LED utilizando una salida digital.","title":"Escritura de Salidas Digitales"},{"location":"digital_io/#ejemplo-control-de-un-led","text":"Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 LED 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: Una vez montado, vamos a escribir un programa para hacer parpadear el LED. from machine import Pin import time pin_number = 17 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando led = Pin(pin_number, Pin.OUT) while True: led.value(1) # Encender el LED time.sleep(1) # Esperar 1 segundo led.value(0) # Apagar el LED time.sleep(1) # Esperar 1 segundo Este programa encender\u00e1 y apagar\u00e1 el LED cada segundo, demostrando el uso de una salida digital para controlar un dispositivo externo. Como vemos en el c\u00f3digo, utilizamos la funci\u00f3n time.sleep() para crear un retraso entre los cambios de estado del LED. Ahora, nos centraremos en la lectura de una entrada digital utilizando un bot\u00f3n. Para ello, vamos a utilizar el bot\u00f3n como nuevo componente. Un bot\u00f3n es un interruptor que, cuando se presiona, conecta el pin a tierra (0V). Para evitar que el pin quede \"flotando\" cuando el bot\u00f3n no est\u00e1 presionado, utilizaremos una resistencia pull-up interna.","title":"Ejemplo: Control de un LED"},{"location":"digital_io/#ejemplo-lectura-de-un-boton","text":"Para este ejemplo, necesitar\u00e1s los siguientes componentes: 1 Bot\u00f3n Cables de conexi\u00f3n Protoboard 1 Resistencia de 10k ohmios (si no usas la resistencia pull-up interna) 1 Resistencia de 220 ohmios (para el LED) 1 LED El montaje se realizar\u00e1 de la siguiente manera: Una vez montado, vamos a escribir un programa para leer el estado del bot\u00f3n y controlar el LED en consecuencia. from machine import Pin import time pin_button = 2 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando para el bot\u00f3n pin_led = 17 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando para el LED button = Pin(pin_button, Pin.IN) led = Pin(pin_led, Pin.OUT) while True: if button.value() == 1: # El bot\u00f3n est\u00e1 presionado led.value(1) # Encender el LED else: led.value(0) # Apagar el LED time.sleep(0.1) # Peque\u00f1o retraso para evitar rebotes En este programa, cuando el bot\u00f3n se presiona, el pin de entrada se conecta a tierra, y el LED se enciende. Cuando el bot\u00f3n no est\u00e1 presionado, el pin de entrada est\u00e1 en alto debido a la resistencia pull-up interna, y el LED se apaga.","title":"Ejemplo: Lectura de un Bot\u00f3n"},{"location":"final/","text":"Proyecto Final Este documento describe el proyecto final que se llevar\u00e1 a cabo al concluir el curso. El objetivo del proyecto es aplicar los conocimientos adquiridos durante las lecciones para resolver un problema real o desarrollar una aplicaci\u00f3n funcional. Vamos a basarnos en la lectura del sensor de sonido KY-037 y publicar los datos obtenidos en un broker MQTT o utilizando una API REST Http utilizando MicroPython. Adem\u00e1s, tambi\u00e9n conectaremos la patilla para medir el umbral digital y que se env\u00ede un evento cuando se supere dicho umbral. Estos datos ser\u00e1n almacenados en una base de datos en la nube para su posterior an\u00e1lisis y visualizaci\u00f3n. Recuerda que se van a realizar varios dispositivos que tendr\u00e1n identificados el aula donde estar\u00e1n instalados. El proyecto incluir\u00e1 las siguientes etapas: 1.- An\u00e1lisis de Requisitos : Definir los objetivos del proyecto, las funcionalidades necesarias y los requisitos t\u00e9cnicos. 2.- Dise\u00f1o del Sistema : Planificar la arquitectura del sistema, seleccionar los componentes de hardware y dise\u00f1ar la estructura del software; e incluso simularlo usando el simulador Wokwi. 3.- Implementaci\u00f3n : Desarrollar el c\u00f3digo en MicroPython para la lectura del sensor KY-037, la conexi\u00f3n al broker MQTT o API REST, y el env\u00edo de datos. 4.- Implementar Broker y almacenamiento en la nube : Configurar un broker MQTT (como Mosquitto o HiveMQ) o una API REST para recibir los datos, y establecer una base de datos en la nube (como Firebase, AWS DynamoDB, etc.) para almacenar la informaci\u00f3n. 5.- Pruebas y Validaci\u00f3n : Realizar pruebas exhaustivas para asegurar que el sistema funciona correctamente, incluyendo la lectura del sensor, la transmisi\u00f3n de datos y el almacenamiento en la nube. 6.- Documentaci\u00f3n : Crear documentaci\u00f3n detallada del proyecto, incluyendo el dise\u00f1o del sistema, el c\u00f3digo fuente, las instrucciones de configuraci\u00f3n y uso, y cualquier otro aspecto relevante. 7.- Creaci\u00f3n de un Dashboard de Visualizaci\u00f3n : Desarrollar un dashboard utilizando herramientas como Grafana, Power BI o una aplicaci\u00f3n web personalizada para visualizar los datos almacenados en la base de datos en la nube. 8.- Presentaci\u00f3n del Proyecto : Preparar una presentaci\u00f3n para mostrar el proyecto, destacando los objetivos, el proceso de desarrollo, los desaf\u00edos enfrentados y los resultados obtenidos.","title":"Proyecto Final"},{"location":"final/#proyecto-final","text":"Este documento describe el proyecto final que se llevar\u00e1 a cabo al concluir el curso. El objetivo del proyecto es aplicar los conocimientos adquiridos durante las lecciones para resolver un problema real o desarrollar una aplicaci\u00f3n funcional. Vamos a basarnos en la lectura del sensor de sonido KY-037 y publicar los datos obtenidos en un broker MQTT o utilizando una API REST Http utilizando MicroPython. Adem\u00e1s, tambi\u00e9n conectaremos la patilla para medir el umbral digital y que se env\u00ede un evento cuando se supere dicho umbral. Estos datos ser\u00e1n almacenados en una base de datos en la nube para su posterior an\u00e1lisis y visualizaci\u00f3n. Recuerda que se van a realizar varios dispositivos que tendr\u00e1n identificados el aula donde estar\u00e1n instalados. El proyecto incluir\u00e1 las siguientes etapas: 1.- An\u00e1lisis de Requisitos : Definir los objetivos del proyecto, las funcionalidades necesarias y los requisitos t\u00e9cnicos. 2.- Dise\u00f1o del Sistema : Planificar la arquitectura del sistema, seleccionar los componentes de hardware y dise\u00f1ar la estructura del software; e incluso simularlo usando el simulador Wokwi. 3.- Implementaci\u00f3n : Desarrollar el c\u00f3digo en MicroPython para la lectura del sensor KY-037, la conexi\u00f3n al broker MQTT o API REST, y el env\u00edo de datos. 4.- Implementar Broker y almacenamiento en la nube : Configurar un broker MQTT (como Mosquitto o HiveMQ) o una API REST para recibir los datos, y establecer una base de datos en la nube (como Firebase, AWS DynamoDB, etc.) para almacenar la informaci\u00f3n. 5.- Pruebas y Validaci\u00f3n : Realizar pruebas exhaustivas para asegurar que el sistema funciona correctamente, incluyendo la lectura del sensor, la transmisi\u00f3n de datos y el almacenamiento en la nube. 6.- Documentaci\u00f3n : Crear documentaci\u00f3n detallada del proyecto, incluyendo el dise\u00f1o del sistema, el c\u00f3digo fuente, las instrucciones de configuraci\u00f3n y uso, y cualquier otro aspecto relevante. 7.- Creaci\u00f3n de un Dashboard de Visualizaci\u00f3n : Desarrollar un dashboard utilizando herramientas como Grafana, Power BI o una aplicaci\u00f3n web personalizada para visualizar los datos almacenados en la base de datos en la nube. 8.- Presentaci\u00f3n del Proyecto : Preparar una presentaci\u00f3n para mostrar el proyecto, destacando los objetivos, el proceso de desarrollo, los desaf\u00edos enfrentados y los resultados obtenidos.","title":"Proyecto Final"},{"location":"getting_started/","text":"Primeros Pasos Una vez tenemos todo instalado, ya podemos empezar a utilizar nuestra placa. Usar el Interprete En nuestra placa esta instalado el interprete REPL como si de cualquier distribuci\u00f3n python se tratara. Por lo que podemos trabajar con este interprete y dar algunas ordenes. Si estamos utilizando Thonny, podemos verlo en la parte inferior de la pantalla. NOTA : Recuerda configurar correctamente el puerto de la placa a utilizar. Eletr\u00f3nica B\u00e1sica Vamos a ver algunos conceptos b\u00e1sicos de electr\u00f3nica que nos permitir\u00e1n entender mejor como funcionan las placas y los microcontroladores. GPIO Los GPIO (General Purpose Input Output) son los pines de entrada y salida que tienen las placas para poder interactuar con el exterior. Estos pines pueden ser configurados como entradas o salidas digitales. Entradas Digitales Las entradas digitales son aquellas que permiten leer el estado de un pin, es decir, si est\u00e1 en alto (1) o en bajo (0). Esto nos permite leer el estado de sensores, botones, etc. Salidas Digitales Las salidas digitales son aquellas que permiten enviar una se\u00f1al a un pin, es decir, ponerlo en alto (1) o en bajo (0). Configuraci\u00f3n de Pines en MicroPython En MicroPython, para configurar los pines GPIO, utilizamos la clase Pin del m\u00f3dulo machine . Esta clase nos permite configurar un pin como entrada o salida. BreadBoard Una BreadBoard es una placa de pruebas que nos permite realizar montajes electr\u00f3nicos sin necesidad de soldar. Esto nos permite realizar prototipos de manera r\u00e1pida y sencilla. En la siguiente imagen podemos ver una BreadBoard t\u00edpica: Esto nos permitir\u00e1 interactuar directamente con nuestra placa. Ya que permite conectar dispositivos electr\u00f3nicos como leds, resistencias, botones, sensores, etc. Las breadboards tienen filas y columnas de conexiones que nos permiten conectar los componentes entre s\u00ed y con la placa. Una breadboard t\u00edpica tiene dos \u00e1reas principales: la zona de alimentaci\u00f3n (power rails) y la zona de conexiones (terminal strips). En la zona de alimentaci\u00f3n, encontramos dos filas largas en cada lado de la breadboard que se utilizan para distribuir la alimentaci\u00f3n (Vcc) y la tierra (GND) a los componentes conectados en la breadboard. En la zona de conexiones, encontramos filas y columnas de agujeros donde podemos insertar los componentes electr\u00f3nicos. Cada fila est\u00e1 conectada internamente, lo que significa que todos los agujeros en una fila est\u00e1n conectados entre s\u00ed. LED y Resistencia Un LED (Light Emitting Diode) es un diodo que emite luz cuando pasa una corriente el\u00e9ctrica a trav\u00e9s de \u00e9l. Los LEDs tienen dos patas: la pata larga es el \u00e1nodo (positivo) y la pata corta es el c\u00e1todo (negativo). Para proteger el LED y evitar que se queme, es necesario utilizar una resistencia en serie con el LED. La resistencia limita la corriente que pasa a trav\u00e9s del LED. Primer Programa con MicroPython Vamos a ponernos ya manos a la obra; crearemos nuestro primer programa con MicroPython. Comenzando por lo m\u00e1s sencillo. Encender y apagar un Led. Primero, vamos a realizar nuestro primer montaje; por lo que necesitaremos los siguientes materiales: 1 placa ESP32 o Raspberry Pi PICO 1 BreadBoard 1 Led 1 Resistencia 220Ohmios cables Dupont Realizaremos el siguiente Montaje NOTA : En el caso de Raspberry Pi usar el mismo GPIO Una vez hecho esto, crearemos en thonny el siguiente c\u00f3digo Python. from machine import Pin from time import sleep #El Pin del led es el 2 que corresponde al GPIO2 ledpin=2 pin = Pin(ledpin, Pin.OUT) while True: pin.value(1) sleep(1) pin.value(0) sleep(1) NOTA : Dependiendo de la placa el n\u00famero de Pin puede cambiar. Para la Raspberry Pi Pico es el GPIO25 mientas para la Raspberry Pi Pico W es el GPIO0. Consulta la documentaci\u00f3n del fabricante. Una vez escrito, lo guardaremos. Cuando le demos a guardar, nos preguntar\u00e1 donde lo queremos almacenar; si en nuestro equipo, o en nuestra placa. Una vez almacenado, ya podemos verlo en nuestra placa. Podemos tener varios ficheros y verlos si pulsamos la opci\u00f3n Visualizaci\u00f3n->archivos . Podremos ver el listado de ficheros en nuestra placa y gestionarlos. Una vez subido el fichero y ejecutado, ya deber\u00edamos de poder ver parpadear nuestro led. NOTA : En caso de no verlo, comprueba la polaridad del Led la patilla Larga es siempre la negativa. Ejercicio con 2 Leds Os dejamos un Ejercicio con dos leds para que ve\u00e1is como funcionar\u00eda: Con el c\u00f3digo correspondiente. from machine import Pin from time import sleep ledpin=2 ledpin2=4 pin = Pin(ledpin, Pin.OUT) pin2 = Pin(ledpin2, Pin.OUT) while True: pin.value(1) pin2.value(1) sleep(1) pin.value(0) pin2.value(0) sleep(1) Botones Con MicroPython Tras ver como utilizar la salida a trav\u00e9s de los leds; vamos a tratar de utilizar pulsadores para poder utilizar las entradas del microcontrolador. En este caso tambi\u00e9n utilizaremos la clase Pin pero en este caso configuraremos cada puerto en modo IN. Para este montaje, usaremos los siguientes materiales: 1 Placa ESP32 o Raspberry Pi PIco 1 BreadBoard 1 Led 1 resistencia 220Ohmios o similar. 1 resistenia 1KOhmios o similar. 1 Boton cables Dupont Veamos el montaje: Y seguidamente mostramos el c\u00f3digo: from machine import Pin import time button=Pin(2,Pin.IN) led=Pin(16,Pin.OUT) while True: state=button.value() led.value(state) time.sleep(0.5) Ejercicio : Realizar un montaje que sea necesario pulsar 2 Botones para que se encienda el led.","title":"Primeros Pasos"},{"location":"getting_started/#primeros-pasos","text":"Una vez tenemos todo instalado, ya podemos empezar a utilizar nuestra placa.","title":"Primeros Pasos"},{"location":"getting_started/#usar-el-interprete","text":"En nuestra placa esta instalado el interprete REPL como si de cualquier distribuci\u00f3n python se tratara. Por lo que podemos trabajar con este interprete y dar algunas ordenes. Si estamos utilizando Thonny, podemos verlo en la parte inferior de la pantalla. NOTA : Recuerda configurar correctamente el puerto de la placa a utilizar.","title":"Usar el Interprete"},{"location":"getting_started/#eletronica-basica","text":"Vamos a ver algunos conceptos b\u00e1sicos de electr\u00f3nica que nos permitir\u00e1n entender mejor como funcionan las placas y los microcontroladores.","title":"Eletr\u00f3nica B\u00e1sica"},{"location":"getting_started/#gpio","text":"Los GPIO (General Purpose Input Output) son los pines de entrada y salida que tienen las placas para poder interactuar con el exterior. Estos pines pueden ser configurados como entradas o salidas digitales.","title":"GPIO"},{"location":"getting_started/#entradas-digitales","text":"Las entradas digitales son aquellas que permiten leer el estado de un pin, es decir, si est\u00e1 en alto (1) o en bajo (0). Esto nos permite leer el estado de sensores, botones, etc.","title":"Entradas Digitales"},{"location":"getting_started/#salidas-digitales","text":"Las salidas digitales son aquellas que permiten enviar una se\u00f1al a un pin, es decir, ponerlo en alto (1) o en bajo (0).","title":"Salidas Digitales"},{"location":"getting_started/#configuracion-de-pines-en-micropython","text":"En MicroPython, para configurar los pines GPIO, utilizamos la clase Pin del m\u00f3dulo machine . Esta clase nos permite configurar un pin como entrada o salida.","title":"Configuraci\u00f3n de Pines en MicroPython"},{"location":"getting_started/#breadboard","text":"Una BreadBoard es una placa de pruebas que nos permite realizar montajes electr\u00f3nicos sin necesidad de soldar. Esto nos permite realizar prototipos de manera r\u00e1pida y sencilla. En la siguiente imagen podemos ver una BreadBoard t\u00edpica: Esto nos permitir\u00e1 interactuar directamente con nuestra placa. Ya que permite conectar dispositivos electr\u00f3nicos como leds, resistencias, botones, sensores, etc. Las breadboards tienen filas y columnas de conexiones que nos permiten conectar los componentes entre s\u00ed y con la placa. Una breadboard t\u00edpica tiene dos \u00e1reas principales: la zona de alimentaci\u00f3n (power rails) y la zona de conexiones (terminal strips). En la zona de alimentaci\u00f3n, encontramos dos filas largas en cada lado de la breadboard que se utilizan para distribuir la alimentaci\u00f3n (Vcc) y la tierra (GND) a los componentes conectados en la breadboard. En la zona de conexiones, encontramos filas y columnas de agujeros donde podemos insertar los componentes electr\u00f3nicos. Cada fila est\u00e1 conectada internamente, lo que significa que todos los agujeros en una fila est\u00e1n conectados entre s\u00ed.","title":"BreadBoard"},{"location":"getting_started/#led-y-resistencia","text":"Un LED (Light Emitting Diode) es un diodo que emite luz cuando pasa una corriente el\u00e9ctrica a trav\u00e9s de \u00e9l. Los LEDs tienen dos patas: la pata larga es el \u00e1nodo (positivo) y la pata corta es el c\u00e1todo (negativo). Para proteger el LED y evitar que se queme, es necesario utilizar una resistencia en serie con el LED. La resistencia limita la corriente que pasa a trav\u00e9s del LED.","title":"LED y Resistencia"},{"location":"getting_started/#primer-programa-con-micropython","text":"Vamos a ponernos ya manos a la obra; crearemos nuestro primer programa con MicroPython. Comenzando por lo m\u00e1s sencillo. Encender y apagar un Led. Primero, vamos a realizar nuestro primer montaje; por lo que necesitaremos los siguientes materiales: 1 placa ESP32 o Raspberry Pi PICO 1 BreadBoard 1 Led 1 Resistencia 220Ohmios cables Dupont Realizaremos el siguiente Montaje NOTA : En el caso de Raspberry Pi usar el mismo GPIO Una vez hecho esto, crearemos en thonny el siguiente c\u00f3digo Python. from machine import Pin from time import sleep #El Pin del led es el 2 que corresponde al GPIO2 ledpin=2 pin = Pin(ledpin, Pin.OUT) while True: pin.value(1) sleep(1) pin.value(0) sleep(1) NOTA : Dependiendo de la placa el n\u00famero de Pin puede cambiar. Para la Raspberry Pi Pico es el GPIO25 mientas para la Raspberry Pi Pico W es el GPIO0. Consulta la documentaci\u00f3n del fabricante. Una vez escrito, lo guardaremos. Cuando le demos a guardar, nos preguntar\u00e1 donde lo queremos almacenar; si en nuestro equipo, o en nuestra placa. Una vez almacenado, ya podemos verlo en nuestra placa. Podemos tener varios ficheros y verlos si pulsamos la opci\u00f3n Visualizaci\u00f3n->archivos . Podremos ver el listado de ficheros en nuestra placa y gestionarlos. Una vez subido el fichero y ejecutado, ya deber\u00edamos de poder ver parpadear nuestro led. NOTA : En caso de no verlo, comprueba la polaridad del Led la patilla Larga es siempre la negativa.","title":"Primer Programa con MicroPython"},{"location":"getting_started/#ejercicio-con-2-leds","text":"Os dejamos un Ejercicio con dos leds para que ve\u00e1is como funcionar\u00eda: Con el c\u00f3digo correspondiente. from machine import Pin from time import sleep ledpin=2 ledpin2=4 pin = Pin(ledpin, Pin.OUT) pin2 = Pin(ledpin2, Pin.OUT) while True: pin.value(1) pin2.value(1) sleep(1) pin.value(0) pin2.value(0) sleep(1)","title":"Ejercicio con 2 Leds"},{"location":"getting_started/#botones-con-micropython","text":"Tras ver como utilizar la salida a trav\u00e9s de los leds; vamos a tratar de utilizar pulsadores para poder utilizar las entradas del microcontrolador. En este caso tambi\u00e9n utilizaremos la clase Pin pero en este caso configuraremos cada puerto en modo IN. Para este montaje, usaremos los siguientes materiales: 1 Placa ESP32 o Raspberry Pi PIco 1 BreadBoard 1 Led 1 resistencia 220Ohmios o similar. 1 resistenia 1KOhmios o similar. 1 Boton cables Dupont Veamos el montaje: Y seguidamente mostramos el c\u00f3digo: from machine import Pin import time button=Pin(2,Pin.IN) led=Pin(16,Pin.OUT) while True: state=button.value() led.value(state) time.sleep(0.5) Ejercicio : Realizar un montaje que sea necesario pulsar 2 Botones para que se encienda el led.","title":"Botones Con MicroPython"},{"location":"http/","text":"Comunicaci\u00f3n HTTP Uno de los usos m\u00e1s comunes de la conectividad en dispositivos IoT es la comunicaci\u00f3n a trav\u00e9s del protocolo HTTP (HyperText Transfer Protocol). Este protocolo permite a los dispositivos enviar y recibir datos a trav\u00e9s de la web, interactuando con servidores y servicios en l\u00ednea. En esta secci\u00f3n, veremos por un lado, la posibilidad de realizar peticiones HTTP como cliente, y por otro lado, c\u00f3mo configurar nuestro dispositivo para actuar como un servidor HTTP. NOTA : Para todos estos ejemplos, es necesario tener una conexi\u00f3n a una red Wi-Fi activa. Aseg\u00farate de haber configurado correctamente la conexi\u00f3n Wi-Fi antes de ejecutar los ejemplos de esta secci\u00f3n. Cliente HTTP Para realizar peticiones HTTP desde nuestro dispositivo, utilizamos la librer\u00eda urequests , que proporciona una interfaz sencilla para enviar solicitudes HTTP. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo realizar una solicitud GET a un servidor web: Sin embargo, esta biblioteca no est\u00e1 incluida por defecto en todas las implementaciones de MicroPython, por lo que es posible que necesites descargarla e instalarla manualmente en tu dispositivo. MicroPython tiene incluido un peque\u00f1o gestor de paquetes llamado upip , que permite instalar paquetes adicionales. Para instalar urequests , puedes utilizar el siguiente comando en la consola REPL de MicroPython: import upip upip.install('micropython-urequests') Por lo que una vez hecho esto, ya podemos utilizar la librer\u00eda urequests para realizar peticiones HTTP. Esta biblioteca es an\u00e1loga a la popular biblioteca requests de Python, pero adaptada para funcionar en entornos con recursos limitados como MicroPython. Vamos a ver un ejemplo de uso para la API de informaci\u00f3n meteorol\u00f3gica de OpenWeatherMap; la cual puedes encontrar informaci\u00f3n en: https://openweathermap.org/api Veammos c\u00f3mo realizar una solicitud GET para obtener el clima actual de una ciudad espec\u00edfica: import urequests city='Almer\u00eda' api_key='TU_API_KEY' response = urequests.get(f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}') if response.status_code == 200: data = response.json() print(\"Clima en\", city) print(\"Temperatura:\", data['main']['temp']) print(\"Descripci\u00f3n:\", data['weather'][0]['description']) else: print(\"Error al obtener los datos:\", response.status_code) response.close() En este ejemplo, reemplaza 'TU_API_KEY' con tu clave de API de OpenWeatherMap. El c\u00f3digo realiza una solicitud GET para obtener el clima actual de la ciudad especificada y luego imprime la temperatura y la descripci\u00f3n del clima en la consola. Servidor HTTP Adem\u00e1s de actuar como cliente HTTP, nuestro dispositivo tambi\u00e9n puede funcionar como un servidor HTTP, permitiendo que otros dispositivos se conecten a \u00e9l y soliciten informaci\u00f3n o controlen sus funciones. Para ello, utilizamos la librer\u00eda socket para crear un servidor b\u00e1sico. Vamos a tratar de encender un led a trav\u00e9s deun servidor HTTP simple. Para ello necesitaremos los siguientes componentes: 1 LED 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard Realizando el montaje de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo configurar un servidor HTTP simple: import socket from machine import Pin led = Pin(14, Pin.OUT) # Cambia el n\u00famero del pin seg\u00fan tu conexi\u00f3n addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1] s = socket.socket() s.bind(addr) s.listen(1) print('Servidor HTTP escuchando en http://0.0.0.0:80') while True: cl, addr = s.accept() print('Cliente conectado desde', addr) request = cl.recv(1024) request_str = request.decode('utf-8') print('Solicitud HTTP:') print(request_str) # Control simple del LED a trav\u00e9s de la URL if '/led/on' in request_str: led.value(1) elif '/led/off' in request_str: led.value(0) response = \"\"\"HTTP/1.1 200 OK Content-Type: text/html <!DOCTYPE html> <html> <head><title>Servidor HTTP en MicroPython</title></head> <body> <h1>Servidor HTTP en MicroPython</h1> <p>LED est\u00e1 {}</p> <a href=\"/led/on\">Encender LED</a><br> <a href=\"/led/off\">Apagar LED</a> </body> </html> \"\"\".format('ENCENDIDO' if led.value() else 'APAGADO') cl.send(response) cl.close() En este ejemplo, el servidor HTTP escucha en el puerto 80 y responde a las solicitudes entrantes. Adem\u00e1s, permite controlar un LED conectado al pin especificado mediante las rutas /led/on y /led/off . Cuando un cliente accede a estas rutas, el LED se enciende o apaga respectivamente, y la p\u00e1gina web muestra el estado actual del LED.","title":"Comunicaci\u00f3n Http"},{"location":"http/#comunicacion-http","text":"Uno de los usos m\u00e1s comunes de la conectividad en dispositivos IoT es la comunicaci\u00f3n a trav\u00e9s del protocolo HTTP (HyperText Transfer Protocol). Este protocolo permite a los dispositivos enviar y recibir datos a trav\u00e9s de la web, interactuando con servidores y servicios en l\u00ednea. En esta secci\u00f3n, veremos por un lado, la posibilidad de realizar peticiones HTTP como cliente, y por otro lado, c\u00f3mo configurar nuestro dispositivo para actuar como un servidor HTTP. NOTA : Para todos estos ejemplos, es necesario tener una conexi\u00f3n a una red Wi-Fi activa. Aseg\u00farate de haber configurado correctamente la conexi\u00f3n Wi-Fi antes de ejecutar los ejemplos de esta secci\u00f3n.","title":"Comunicaci\u00f3n HTTP"},{"location":"http/#cliente-http","text":"Para realizar peticiones HTTP desde nuestro dispositivo, utilizamos la librer\u00eda urequests , que proporciona una interfaz sencilla para enviar solicitudes HTTP. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo realizar una solicitud GET a un servidor web: Sin embargo, esta biblioteca no est\u00e1 incluida por defecto en todas las implementaciones de MicroPython, por lo que es posible que necesites descargarla e instalarla manualmente en tu dispositivo. MicroPython tiene incluido un peque\u00f1o gestor de paquetes llamado upip , que permite instalar paquetes adicionales. Para instalar urequests , puedes utilizar el siguiente comando en la consola REPL de MicroPython: import upip upip.install('micropython-urequests') Por lo que una vez hecho esto, ya podemos utilizar la librer\u00eda urequests para realizar peticiones HTTP. Esta biblioteca es an\u00e1loga a la popular biblioteca requests de Python, pero adaptada para funcionar en entornos con recursos limitados como MicroPython. Vamos a ver un ejemplo de uso para la API de informaci\u00f3n meteorol\u00f3gica de OpenWeatherMap; la cual puedes encontrar informaci\u00f3n en: https://openweathermap.org/api Veammos c\u00f3mo realizar una solicitud GET para obtener el clima actual de una ciudad espec\u00edfica: import urequests city='Almer\u00eda' api_key='TU_API_KEY' response = urequests.get(f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}') if response.status_code == 200: data = response.json() print(\"Clima en\", city) print(\"Temperatura:\", data['main']['temp']) print(\"Descripci\u00f3n:\", data['weather'][0]['description']) else: print(\"Error al obtener los datos:\", response.status_code) response.close() En este ejemplo, reemplaza 'TU_API_KEY' con tu clave de API de OpenWeatherMap. El c\u00f3digo realiza una solicitud GET para obtener el clima actual de la ciudad especificada y luego imprime la temperatura y la descripci\u00f3n del clima en la consola.","title":"Cliente HTTP"},{"location":"http/#servidor-http","text":"Adem\u00e1s de actuar como cliente HTTP, nuestro dispositivo tambi\u00e9n puede funcionar como un servidor HTTP, permitiendo que otros dispositivos se conecten a \u00e9l y soliciten informaci\u00f3n o controlen sus funciones. Para ello, utilizamos la librer\u00eda socket para crear un servidor b\u00e1sico. Vamos a tratar de encender un led a trav\u00e9s deun servidor HTTP simple. Para ello necesitaremos los siguientes componentes: 1 LED 1 Resistencia de 220 ohmios Cables de conexi\u00f3n Protoboard Realizando el montaje de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo configurar un servidor HTTP simple: import socket from machine import Pin led = Pin(14, Pin.OUT) # Cambia el n\u00famero del pin seg\u00fan tu conexi\u00f3n addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1] s = socket.socket() s.bind(addr) s.listen(1) print('Servidor HTTP escuchando en http://0.0.0.0:80') while True: cl, addr = s.accept() print('Cliente conectado desde', addr) request = cl.recv(1024) request_str = request.decode('utf-8') print('Solicitud HTTP:') print(request_str) # Control simple del LED a trav\u00e9s de la URL if '/led/on' in request_str: led.value(1) elif '/led/off' in request_str: led.value(0) response = \"\"\"HTTP/1.1 200 OK Content-Type: text/html <!DOCTYPE html> <html> <head><title>Servidor HTTP en MicroPython</title></head> <body> <h1>Servidor HTTP en MicroPython</h1> <p>LED est\u00e1 {}</p> <a href=\"/led/on\">Encender LED</a><br> <a href=\"/led/off\">Apagar LED</a> </body> </html> \"\"\".format('ENCENDIDO' if led.value() else 'APAGADO') cl.send(response) cl.close() En este ejemplo, el servidor HTTP escucha en el puerto 80 y responde a las solicitudes entrantes. Adem\u00e1s, permite controlar un LED conectado al pin especificado mediante las rutas /led/on y /led/off . Cuando un cliente accede a estas rutas, el LED se enciende o apaga respectivamente, y la p\u00e1gina web muestra el estado actual del LED.","title":"Servidor HTTP"},{"location":"install/","text":"Instalaci\u00f3n MicroPython Una vez tenemos nuestro entorno instalado y nuestras placas listas, vamos a proceder a instalar en ellas el interprete de MicroPython. Dependiendo de la placa, las instrucciones son distintas pero vamos a ver varios m\u00e9todos de instalaci\u00f3n. Para este paso, ya necesitaremos conectar nuestras placas a trav\u00e9s de un cable USB (microUSB), para poder conectarlo a nuestro equipo. ESP32 Para quienes usen ESP32, necesitaran tener un par de cosas en cuenta. En primer lugar, si esta utilizando Windows, necesitar\u00e1 instalar los drivers para poder detectar la interfaz USB de nuestra placa. Para ello, necesitar\u00e1 instalar los drivers para el controlador CP210. Puedes encontrarlos en el siguiente enlace . Una vez instalados, ya solo queda descargar la \u00faltima versi\u00f3n del interprete de micropython para el ESP32. Puedes encontrarla en el siguiente enlace . Puedes encontrar m\u00e1s informaci\u00f3n sobre otras placas y versiones de MicroPython en la p\u00e1gina oficial: https://micropython.org Instalar usando Thonny El primer metodo de instalaci\u00f3n que veremos, es utilizando la utilidad que nos trae Thonny. Para ello, abriremos thonny y seleccionaremos el men\u00fa ejecutar->Elegir interprete... y en la pantalla seleccionaremos primero el tipo de interprete (MicroPython ESP32 o MicroPython Raspberry Pi Pico). Una vez hecho esto, pulsaremos en el enlace abajo derecha \"instalar o actualizar software\". En este dialogo, podremos seleccionar en primer lugar, el dispositivo (puerto COM o fichero /dev) y donde se encuentra el interprete a instalar. Si esta instalando en un ESP32, seleccione el fichero .bin que descarg\u00f3 anteriormente. Si esta instalando en una Raspberry Pi Pico, espere unos segundos a que la placa sea detectada. NOTA : Si no detecta la Raspberry pi Pico, pulse el bot\u00f3n bootsel de la placa mientras inserta el USB. Instalaci\u00f3n Manual En caso de ser necesario, se puede instalar manualmente el interprete de MicroPython. Para instalarlo, necesitaremos la herramienta esptool (Solo para ESP32). Que podemos instalar con pip. pip install esptool Una vez instalada, podemos pasar a instalar el interprete. ESP32 Para la placa ESP32, usaremos la herramienta anteriormente mencionada. Primero, borraremos la flash: # Cambia /dev/ttyUSB0 por el nombre del puerto (COMX en windows) esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash Una vez borrada la flash, podremos instalar el interprete: # No olvides cambiar tanto puerto como nombre del fichero esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 esp32-20190125-v1.10.bin Una vez hecho esto, ya puedes utilizar el interprete. Raspberry Pi Pico Con Raspberry Pi Pico, la instalaci\u00f3n es mucho m\u00e1s sencilla ya que no requiere de utilizar la herramienta esptool . Solo conecta la placa pulsando el bot\u00f3n bootsel y se montar\u00e1 un volumen en tu equipo (como si de una unidad USB se tratara). Despu\u00e9s descarga el interprete microPython para Raspberry Pi Pico: Raspberry Pi Pico Raspberry Pi Pico W Una vez decargado, pega el fichero en la unidad montada. Una vez terminado expulsa la unidad y ya estar\u00e1 instalado.","title":"Instalar MicroPython"},{"location":"install/#instalacion-micropython","text":"Una vez tenemos nuestro entorno instalado y nuestras placas listas, vamos a proceder a instalar en ellas el interprete de MicroPython. Dependiendo de la placa, las instrucciones son distintas pero vamos a ver varios m\u00e9todos de instalaci\u00f3n. Para este paso, ya necesitaremos conectar nuestras placas a trav\u00e9s de un cable USB (microUSB), para poder conectarlo a nuestro equipo.","title":"Instalaci\u00f3n MicroPython"},{"location":"install/#esp32","text":"Para quienes usen ESP32, necesitaran tener un par de cosas en cuenta. En primer lugar, si esta utilizando Windows, necesitar\u00e1 instalar los drivers para poder detectar la interfaz USB de nuestra placa. Para ello, necesitar\u00e1 instalar los drivers para el controlador CP210. Puedes encontrarlos en el siguiente enlace . Una vez instalados, ya solo queda descargar la \u00faltima versi\u00f3n del interprete de micropython para el ESP32. Puedes encontrarla en el siguiente enlace . Puedes encontrar m\u00e1s informaci\u00f3n sobre otras placas y versiones de MicroPython en la p\u00e1gina oficial: https://micropython.org","title":"ESP32"},{"location":"install/#instalar-usando-thonny","text":"El primer metodo de instalaci\u00f3n que veremos, es utilizando la utilidad que nos trae Thonny. Para ello, abriremos thonny y seleccionaremos el men\u00fa ejecutar->Elegir interprete... y en la pantalla seleccionaremos primero el tipo de interprete (MicroPython ESP32 o MicroPython Raspberry Pi Pico). Una vez hecho esto, pulsaremos en el enlace abajo derecha \"instalar o actualizar software\". En este dialogo, podremos seleccionar en primer lugar, el dispositivo (puerto COM o fichero /dev) y donde se encuentra el interprete a instalar. Si esta instalando en un ESP32, seleccione el fichero .bin que descarg\u00f3 anteriormente. Si esta instalando en una Raspberry Pi Pico, espere unos segundos a que la placa sea detectada. NOTA : Si no detecta la Raspberry pi Pico, pulse el bot\u00f3n bootsel de la placa mientras inserta el USB.","title":"Instalar usando Thonny"},{"location":"install/#instalacion-manual","text":"En caso de ser necesario, se puede instalar manualmente el interprete de MicroPython. Para instalarlo, necesitaremos la herramienta esptool (Solo para ESP32). Que podemos instalar con pip. pip install esptool Una vez instalada, podemos pasar a instalar el interprete.","title":"Instalaci\u00f3n Manual"},{"location":"install/#esp32_1","text":"Para la placa ESP32, usaremos la herramienta anteriormente mencionada. Primero, borraremos la flash: # Cambia /dev/ttyUSB0 por el nombre del puerto (COMX en windows) esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash Una vez borrada la flash, podremos instalar el interprete: # No olvides cambiar tanto puerto como nombre del fichero esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 460800 write_flash -z 0x1000 esp32-20190125-v1.10.bin Una vez hecho esto, ya puedes utilizar el interprete.","title":"ESP32"},{"location":"install/#raspberry-pi-pico","text":"Con Raspberry Pi Pico, la instalaci\u00f3n es mucho m\u00e1s sencilla ya que no requiere de utilizar la herramienta esptool . Solo conecta la placa pulsando el bot\u00f3n bootsel y se montar\u00e1 un volumen en tu equipo (como si de una unidad USB se tratara). Despu\u00e9s descarga el interprete microPython para Raspberry Pi Pico: Raspberry Pi Pico Raspberry Pi Pico W Una vez decargado, pega el fichero en la unidad montada. Una vez terminado expulsa la unidad y ya estar\u00e1 instalado.","title":"Raspberry Pi Pico"},{"location":"install_env/","text":"Instalaci\u00f3n del Entorno En esta p\u00e1gina encontras informaci\u00f3n sobre que necesitaremos para trabajar con MicroPython. Los programas o utilidades que necesitaremos son: Python Thonny Pasaremos a repasar cada elemento: Python Para poder utilizar MicroPython y poder interactuar con las distintas placas, necesitaremos tener instalado Python 3.7 o superior. Podemos descargar Python desde el siguiente enlace . Tambien podemos utilizar el gestor de paquetes de nuestra distribucion (Linux). Para comprobar que version de python tenemos instalada, podemos usar el siguiente comando: python --version Tambi\u00e9n es importante instalar el gestor de paquetes pip ; para poder instalar las herramientas que necesitemos. Podemos comprobar que esta instalado con el siguiente comando: pip --version En caso de error, se puede usar el siguiente comando: python -m pip --version Para poder instalar pip usaremos el siguiente comando (En caso de no tenerlo instalado). python -m ensurepip --upgrade Thonny Para este curso, usaremos el editor Thonny el cual nos va a permitir subir y ejecutar programas en nuestra placa programable. Thonny es un editor muy ligero que esta construido en python y se puede utilizar de forma muy sencilla para crear nuestros programas tanto en local, como en MicroPython. Para instalar thonny, podemos realizarlo de dos formas Instalaci\u00f3n propia Nos descargaremos e instalaremos el software del siguiente enlace . Instalaci\u00f3n usando Pip Para instalar usando Pip podemos usar los siguientes comandos: pip install thonny pip install thonny-esp # instala las extensiones para micropython Despues simplemente escribiremos el siguiente comando: thonny En caso de error: python -m thonny","title":"instalar Entorno"},{"location":"install_env/#instalacion-del-entorno","text":"En esta p\u00e1gina encontras informaci\u00f3n sobre que necesitaremos para trabajar con MicroPython. Los programas o utilidades que necesitaremos son: Python Thonny Pasaremos a repasar cada elemento:","title":"Instalaci\u00f3n del Entorno"},{"location":"install_env/#python","text":"Para poder utilizar MicroPython y poder interactuar con las distintas placas, necesitaremos tener instalado Python 3.7 o superior. Podemos descargar Python desde el siguiente enlace . Tambien podemos utilizar el gestor de paquetes de nuestra distribucion (Linux). Para comprobar que version de python tenemos instalada, podemos usar el siguiente comando: python --version Tambi\u00e9n es importante instalar el gestor de paquetes pip ; para poder instalar las herramientas que necesitemos. Podemos comprobar que esta instalado con el siguiente comando: pip --version En caso de error, se puede usar el siguiente comando: python -m pip --version Para poder instalar pip usaremos el siguiente comando (En caso de no tenerlo instalado). python -m ensurepip --upgrade","title":"Python"},{"location":"install_env/#thonny","text":"Para este curso, usaremos el editor Thonny el cual nos va a permitir subir y ejecutar programas en nuestra placa programable. Thonny es un editor muy ligero que esta construido en python y se puede utilizar de forma muy sencilla para crear nuestros programas tanto en local, como en MicroPython. Para instalar thonny, podemos realizarlo de dos formas","title":"Thonny"},{"location":"install_env/#instalacion-propia","text":"Nos descargaremos e instalaremos el software del siguiente enlace .","title":"Instalaci\u00f3n propia"},{"location":"install_env/#instalacion-usando-pip","text":"Para instalar usando Pip podemos usar los siguientes comandos: pip install thonny pip install thonny-esp # instala las extensiones para micropython Despues simplemente escribiremos el siguiente comando: thonny En caso de error: python -m thonny","title":"Instalaci\u00f3n usando Pip"},{"location":"interrupts/","text":"Interrupciones Las interrupciones permiten que un microcontrolador responda a eventos externos o internos de manera inmediata, interrumpiendo la ejecuci\u00f3n normal del programa para atender una tarea espec\u00edfica. Esto es especialmente \u00fatil en aplicaciones donde la respuesta r\u00e1pida a eventos es crucial, como en sistemas de control, comunicaci\u00f3n y manejo de sensores. Configuraci\u00f3n de Interrupciones en MicroPython En MicroPython, las interrupciones se pueden configurar utilizando la clase Pin para definir pines de entrada que pueden generar interrupciones. A continuaci\u00f3n, se muestra un ejemplo b\u00e1sico de c\u00f3mo configurar una interrupci\u00f3n en un pin digital: from machine import Pin import time import micropython # Habilitar el manejo de interrupciones micropython.alloc_emergency_exception_buf(100) # Definir una funci\u00f3n de manejo de interrupci\u00f3n def pin_handler(pin): print(\"Interrupci\u00f3n detectada en el pin:\", pin) # Configurar el pin como entrada con una interrupci\u00f3n en el flanco de subida pin = Pin(14, Pin.IN, Pin.PULL_UP) pin.irq(trigger=Pin.IRQ_RISING, handler=pin_handler) # Bucle principal while True: print(\"Esperando interrupci\u00f3n...\") time.sleep(1) En este ejemplo, se configura el pin 14 como una entrada con una resistencia pull-up interna. Se establece una interrupci\u00f3n que se activa en el flanco de subida (cuando el pin cambia de bajo a alto) y llama a la funci\u00f3n pin_handler cuando ocurre la interrupci\u00f3n. Consideraciones Importantes Manejo de Interrupciones : Las funciones de manejo de interrupciones deben ser lo m\u00e1s r\u00e1pidas posible, ya que bloquean la ejecuci\u00f3n del programa principal. Evita operaciones que puedan tardar mucho tiempo, como esperas o llamadas a funciones complejas. Variables Compartidas : Si la funci\u00f3n de interrupci\u00f3n modifica variables que tambi\u00e9n son utilizadas en el programa principal, es importante proteger el acceso a estas variables para evitar condiciones de carrera. Esto se puede hacer deshabilitando temporalmente las interrupciones o utilizando mecanismos de sincronizaci\u00f3n. Prioridad de Interrupciones : Algunos microcontroladores permiten configurar la prioridad de las interrupciones. Aseg\u00farate de entender c\u00f3mo funciona esto en el hardware que est\u00e1s utilizando. Aplicaciones Comunes Lectura de Sensores : Responder r\u00e1pidamente a cambios en sensores, como botones o sensores de movimiento. Comunicaci\u00f3n : Manejar eventos de comunicaci\u00f3n, como la recepci\u00f3n de datos a trav\u00e9s de UART, SPI o I2C. Control de Tiempo Real : Implementar temporizadores y eventos peri\u00f3dicos para tareas de control en tiempo real. Las interrupciones son una herramienta poderosa en la programaci\u00f3n de microcontroladores y pueden mejorar significativamente la eficiencia y capacidad de respuesta de tus aplicaciones en MicroPython.","title":"Interrupciones"},{"location":"interrupts/#interrupciones","text":"Las interrupciones permiten que un microcontrolador responda a eventos externos o internos de manera inmediata, interrumpiendo la ejecuci\u00f3n normal del programa para atender una tarea espec\u00edfica. Esto es especialmente \u00fatil en aplicaciones donde la respuesta r\u00e1pida a eventos es crucial, como en sistemas de control, comunicaci\u00f3n y manejo de sensores.","title":"Interrupciones"},{"location":"interrupts/#configuracion-de-interrupciones-en-micropython","text":"En MicroPython, las interrupciones se pueden configurar utilizando la clase Pin para definir pines de entrada que pueden generar interrupciones. A continuaci\u00f3n, se muestra un ejemplo b\u00e1sico de c\u00f3mo configurar una interrupci\u00f3n en un pin digital: from machine import Pin import time import micropython # Habilitar el manejo de interrupciones micropython.alloc_emergency_exception_buf(100) # Definir una funci\u00f3n de manejo de interrupci\u00f3n def pin_handler(pin): print(\"Interrupci\u00f3n detectada en el pin:\", pin) # Configurar el pin como entrada con una interrupci\u00f3n en el flanco de subida pin = Pin(14, Pin.IN, Pin.PULL_UP) pin.irq(trigger=Pin.IRQ_RISING, handler=pin_handler) # Bucle principal while True: print(\"Esperando interrupci\u00f3n...\") time.sleep(1) En este ejemplo, se configura el pin 14 como una entrada con una resistencia pull-up interna. Se establece una interrupci\u00f3n que se activa en el flanco de subida (cuando el pin cambia de bajo a alto) y llama a la funci\u00f3n pin_handler cuando ocurre la interrupci\u00f3n.","title":"Configuraci\u00f3n de Interrupciones en MicroPython"},{"location":"interrupts/#consideraciones-importantes","text":"Manejo de Interrupciones : Las funciones de manejo de interrupciones deben ser lo m\u00e1s r\u00e1pidas posible, ya que bloquean la ejecuci\u00f3n del programa principal. Evita operaciones que puedan tardar mucho tiempo, como esperas o llamadas a funciones complejas. Variables Compartidas : Si la funci\u00f3n de interrupci\u00f3n modifica variables que tambi\u00e9n son utilizadas en el programa principal, es importante proteger el acceso a estas variables para evitar condiciones de carrera. Esto se puede hacer deshabilitando temporalmente las interrupciones o utilizando mecanismos de sincronizaci\u00f3n. Prioridad de Interrupciones : Algunos microcontroladores permiten configurar la prioridad de las interrupciones. Aseg\u00farate de entender c\u00f3mo funciona esto en el hardware que est\u00e1s utilizando.","title":"Consideraciones Importantes"},{"location":"interrupts/#aplicaciones-comunes","text":"Lectura de Sensores : Responder r\u00e1pidamente a cambios en sensores, como botones o sensores de movimiento. Comunicaci\u00f3n : Manejar eventos de comunicaci\u00f3n, como la recepci\u00f3n de datos a trav\u00e9s de UART, SPI o I2C. Control de Tiempo Real : Implementar temporizadores y eventos peri\u00f3dicos para tareas de control en tiempo real. Las interrupciones son una herramienta poderosa en la programaci\u00f3n de microcontroladores y pueden mejorar significativamente la eficiencia y capacidad de respuesta de tus aplicaciones en MicroPython.","title":"Aplicaciones Comunes"},{"location":"mqtt/","text":"MQTT MQTT (Message Queuing Telemetry Transport) es un protocolo de mensajer\u00eda ligero dise\u00f1ado para dispositivos con recursos limitados y redes de baja ancho de banda. Es ampliamente utilizado en aplicaciones de Internet de las Cosas (IoT) debido a su eficiencia y simplicidad. Conceptos B\u00e1sicos de MQTT Broker : Es el servidor que recibe todos los mensajes, los filtra y los env\u00eda a los clientes suscritos. Ejemplos populares de brokers MQTT incluyen Mosquitto y HiveMQ. Cliente : Es cualquier dispositivo o aplicaci\u00f3n que se conecta al broker para enviar o recibir mensajes. Tema (Topic) : Es una cadena jer\u00e1rquica que se utiliza para organizar y filtrar mensajes. Los clientes pueden publicar mensajes en un tema o suscribirse a un tema para recibir mensajes. Publicar (Publish) : Es el acto de enviar un mensaje a un tema espec\u00edfico. Suscribirse (Subscribe) : Es el acto de registrarse para recibir mensajes de un tema espec\u00edfico. Uso de MQTT en MicroPython Para utilizar MQTT en MicroPython, se puede utilizar la biblioteca umqtt.simple , que proporciona una implementaci\u00f3n b\u00e1sica del cliente MQTT. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo conectar un dispositivo MicroPython a un broker MQTT, publicar mensajes y suscribirse a un tema. Para instalar la biblioteca umqtt.simple , asegurate de tener conectividad a Internet y sigue las instrucciones de instalaci\u00f3n espec\u00edficas para tu entorno MicroPython. import upip upip.install('micropython-umqtt.simple') Ejemplo de C\u00f3digo MQTT import network from umqtt.simple import MQTTClient import time # configuracion broker MQTT MQTT_BROKER = \"test.mosquitto.org\" MQTT_CLIENT_ID = \"micropython_client\" MQTT_TOPIC = b\"test/topic\" # conectar MQTT def connect_mqtt(): client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER) client.connect() return client # publicar mensaje def publish_message(client, message): client.publish(MQTT_TOPIC, message) # main def main(): client = connect_mqtt() while True: publish_message(client, b\"Hello from MicroPython!\") time.sleep(5) if __name__ == \"__main__\": main() Para poder ver los mensajes publicados, puedes utilizar un cliente MQTT como MQTT.fx o cualquier otra herramienta que te permita suscribirte al tema test/topic en el broker test.mosquitto.org . Este c\u00f3digo conecta un dispositivo MicroPython a un broker MQTT p\u00fablico, publica un mensaje cada 5 segundos en el tema especificado y puede ser modificado para adaptarse a tus necesidades espec\u00edficas. Observar mensajes Podemos suscribirnos a los mensajes enviados utilizando la web gratutia: https://testclient-cloud.mqtt.cool/ En esta p\u00e1gina, podemos conectarnos al broker test.mosquitto.org y suscribirnos al tema test/topic para ver los mensajes que nuestro dispositivo MicroPython est\u00e1 publicando. Suscribirse a un Tema Para suscribirse a un tema y recibir mensajes, podemos modificar el ejemplo anterior para incluir una funci\u00f3n de callback que maneje los mensajes entrantes. def message_callback(topic, msg): print(\"Mensaje recibido en el tema {}: {}\".format(topic, msg)) client.set_callback(message_callback) client.subscribe(MQTT_TOPIC)","title":"MQTT"},{"location":"mqtt/#mqtt","text":"MQTT (Message Queuing Telemetry Transport) es un protocolo de mensajer\u00eda ligero dise\u00f1ado para dispositivos con recursos limitados y redes de baja ancho de banda. Es ampliamente utilizado en aplicaciones de Internet de las Cosas (IoT) debido a su eficiencia y simplicidad.","title":"MQTT"},{"location":"mqtt/#conceptos-basicos-de-mqtt","text":"Broker : Es el servidor que recibe todos los mensajes, los filtra y los env\u00eda a los clientes suscritos. Ejemplos populares de brokers MQTT incluyen Mosquitto y HiveMQ. Cliente : Es cualquier dispositivo o aplicaci\u00f3n que se conecta al broker para enviar o recibir mensajes. Tema (Topic) : Es una cadena jer\u00e1rquica que se utiliza para organizar y filtrar mensajes. Los clientes pueden publicar mensajes en un tema o suscribirse a un tema para recibir mensajes. Publicar (Publish) : Es el acto de enviar un mensaje a un tema espec\u00edfico. Suscribirse (Subscribe) : Es el acto de registrarse para recibir mensajes de un tema espec\u00edfico.","title":"Conceptos B\u00e1sicos de MQTT"},{"location":"mqtt/#uso-de-mqtt-en-micropython","text":"Para utilizar MQTT en MicroPython, se puede utilizar la biblioteca umqtt.simple , que proporciona una implementaci\u00f3n b\u00e1sica del cliente MQTT. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo conectar un dispositivo MicroPython a un broker MQTT, publicar mensajes y suscribirse a un tema. Para instalar la biblioteca umqtt.simple , asegurate de tener conectividad a Internet y sigue las instrucciones de instalaci\u00f3n espec\u00edficas para tu entorno MicroPython. import upip upip.install('micropython-umqtt.simple')","title":"Uso de MQTT en MicroPython"},{"location":"mqtt/#ejemplo-de-codigo-mqtt","text":"import network from umqtt.simple import MQTTClient import time # configuracion broker MQTT MQTT_BROKER = \"test.mosquitto.org\" MQTT_CLIENT_ID = \"micropython_client\" MQTT_TOPIC = b\"test/topic\" # conectar MQTT def connect_mqtt(): client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER) client.connect() return client # publicar mensaje def publish_message(client, message): client.publish(MQTT_TOPIC, message) # main def main(): client = connect_mqtt() while True: publish_message(client, b\"Hello from MicroPython!\") time.sleep(5) if __name__ == \"__main__\": main() Para poder ver los mensajes publicados, puedes utilizar un cliente MQTT como MQTT.fx o cualquier otra herramienta que te permita suscribirte al tema test/topic en el broker test.mosquitto.org . Este c\u00f3digo conecta un dispositivo MicroPython a un broker MQTT p\u00fablico, publica un mensaje cada 5 segundos en el tema especificado y puede ser modificado para adaptarse a tus necesidades espec\u00edficas.","title":"Ejemplo de C\u00f3digo MQTT"},{"location":"mqtt/#observar-mensajes","text":"Podemos suscribirnos a los mensajes enviados utilizando la web gratutia: https://testclient-cloud.mqtt.cool/ En esta p\u00e1gina, podemos conectarnos al broker test.mosquitto.org y suscribirnos al tema test/topic para ver los mensajes que nuestro dispositivo MicroPython est\u00e1 publicando.","title":"Observar mensajes"},{"location":"mqtt/#suscribirse-a-un-tema","text":"Para suscribirse a un tema y recibir mensajes, podemos modificar el ejemplo anterior para incluir una funci\u00f3n de callback que maneje los mensajes entrantes. def message_callback(topic, msg): print(\"Mensaje recibido en el tema {}: {}\".format(topic, msg)) client.set_callback(message_callback) client.subscribe(MQTT_TOPIC)","title":"Suscribirse a un Tema"},{"location":"networks/","text":"Redes (Networking) A continuaci\u00f3n, vamos a ver una de las funcionalidades m\u00e1s interesantes de los microcontroladores modernos: la capacidad de conectarse a redes, ya sea a trav\u00e9s de Wi-Fi, Ethernet o Bluetooth. Esto permite que nuestros dispositivos puedan comunicarse entre s\u00ed y con otros dispositivos en la red, as\u00ed como acceder a servicios en la nube. Es importante mencionar que el ESP32 si tiene soporte nativo para Wi-Fi y Bluetooth, mientras que la Raspberry Pi Pico s\u00f3lo los modelos \"W\" soportan Wi-fi, pero no Bluetooth. Para utilizar estas funcionalidades, es necesario contar con las librer\u00edas adecuadas que faciliten la conexi\u00f3n y comunicaci\u00f3n en red. Conexi\u00f3n a una red Wi-Fi Para conectar nuestro dispositivo a una red Wi-Fi, utilizamos la librer\u00eda network . A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo conectarse a una red Wi-Fi utilizando el ESP32 o Raspberry Pi Pico W: import network import time ssid = 'TU_SSID' password = 'TU_CONTRASE\u00d1A' # Crear una instancia de la interfaz Wi-Fi wifi = network.WLAN(network.STA_IF) # Activar la interfaz Wi-Fi wifi.active(True) # Conectarse a la red Wi-Fi wifi.connect(ssid, password) while not wifi.isconnected(): time.sleep(1) print(\"Conectado a la red Wi-Fi:\", wifi.ifconfig()) En este ejemplo, reemplaza 'TU_SSID' y 'TU_CONTRASE\u00d1A' con el nombre y la contrase\u00f1a de tu red Wi-Fi. El c\u00f3digo activa la interfaz Wi-Fi, intenta conectarse a la red especificada y espera hasta que la conexi\u00f3n se establezca correctamente. Una vez conectado, imprime la configuraci\u00f3n de red obtenida (direcci\u00f3n IP, m\u00e1scara de subred, puerta de enlace y servidores DNS). Creaci\u00f3n de Redes Ad-Hoc Adem\u00e1s de conectarse a redes Wi-Fi existentes, algunos dispositivos permiten crear redes ad-hoc o puntos de acceso (AP) para que otros dispositivos puedan conectarse directamente a ellos. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo configurar un punto de acceso Wi-Fi utilizando el ESP32 o Raspberry Pi Pico W: import network # Crear una instancia de la interfaz Wi-Fi en modo AP ap = network.WLAN(network.AP_IF) # Activar la interfaz AP ap.active(True) # Configurar el SSID y la contrase\u00f1a del punto de acceso ap.config(essid='Mi_Punto_de_Acceso', password='mi_contrase\u00f1a') print(\"Punto de acceso creado. SSID: Mi_Punto_de_Acceso\") En este ejemplo, se crea un punto de acceso con el SSID 'Mi_Punto_de_Acceso' y la contrase\u00f1a 'mi_contrase\u00f1a' . Otros dispositivos podr\u00e1n conectarse a este punto de acceso utilizando las credenciales proporcionadas. Uso de Contrase\u00f1as y/o Seguridad Es recomendable utilizar ficheros externos con la configuraci\u00f3n de nuestro SSID y contrase\u00f1as para evitar exponer esta informaci\u00f3n sensible en el c\u00f3digo fuente. De esta manera, podemos mantener nuestras credenciales seguras y facilitar la gesti\u00f3n de m\u00faltiples configuraciones de red. Veamos un ejemplo: # archivo config.py SSID = 'TU_SSID' PASSWORD = 'TU_CONTRASE\u00d1A' # archivo main.py import network from config import SSID, PASSWORD import time # Crear una instancia de la interfaz Wi-Fi wifi = network.WLAN(network.STA_IF) # Activar la interfaz Wi-Fi wifi.active(True) # Conectarse a la red Wi-Fi wifi.connect(SSID, PASSWORD) while not wifi.isconnected(): time.sleep(1) print(\"Conectado a la red Wi-Fi:\", wifi.ifconfig()) En este ejemplo, las credenciales de la red Wi-Fi se almacenan en un archivo separado llamado config.py , lo que ayuda a mantener el c\u00f3digo m\u00e1s limpio y seguro.","title":"Redes"},{"location":"networks/#redes-networking","text":"A continuaci\u00f3n, vamos a ver una de las funcionalidades m\u00e1s interesantes de los microcontroladores modernos: la capacidad de conectarse a redes, ya sea a trav\u00e9s de Wi-Fi, Ethernet o Bluetooth. Esto permite que nuestros dispositivos puedan comunicarse entre s\u00ed y con otros dispositivos en la red, as\u00ed como acceder a servicios en la nube. Es importante mencionar que el ESP32 si tiene soporte nativo para Wi-Fi y Bluetooth, mientras que la Raspberry Pi Pico s\u00f3lo los modelos \"W\" soportan Wi-fi, pero no Bluetooth. Para utilizar estas funcionalidades, es necesario contar con las librer\u00edas adecuadas que faciliten la conexi\u00f3n y comunicaci\u00f3n en red.","title":"Redes (Networking)"},{"location":"networks/#conexion-a-una-red-wi-fi","text":"Para conectar nuestro dispositivo a una red Wi-Fi, utilizamos la librer\u00eda network . A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo conectarse a una red Wi-Fi utilizando el ESP32 o Raspberry Pi Pico W: import network import time ssid = 'TU_SSID' password = 'TU_CONTRASE\u00d1A' # Crear una instancia de la interfaz Wi-Fi wifi = network.WLAN(network.STA_IF) # Activar la interfaz Wi-Fi wifi.active(True) # Conectarse a la red Wi-Fi wifi.connect(ssid, password) while not wifi.isconnected(): time.sleep(1) print(\"Conectado a la red Wi-Fi:\", wifi.ifconfig()) En este ejemplo, reemplaza 'TU_SSID' y 'TU_CONTRASE\u00d1A' con el nombre y la contrase\u00f1a de tu red Wi-Fi. El c\u00f3digo activa la interfaz Wi-Fi, intenta conectarse a la red especificada y espera hasta que la conexi\u00f3n se establezca correctamente. Una vez conectado, imprime la configuraci\u00f3n de red obtenida (direcci\u00f3n IP, m\u00e1scara de subred, puerta de enlace y servidores DNS).","title":"Conexi\u00f3n a una red Wi-Fi"},{"location":"networks/#creacion-de-redes-ad-hoc","text":"Adem\u00e1s de conectarse a redes Wi-Fi existentes, algunos dispositivos permiten crear redes ad-hoc o puntos de acceso (AP) para que otros dispositivos puedan conectarse directamente a ellos. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo configurar un punto de acceso Wi-Fi utilizando el ESP32 o Raspberry Pi Pico W: import network # Crear una instancia de la interfaz Wi-Fi en modo AP ap = network.WLAN(network.AP_IF) # Activar la interfaz AP ap.active(True) # Configurar el SSID y la contrase\u00f1a del punto de acceso ap.config(essid='Mi_Punto_de_Acceso', password='mi_contrase\u00f1a') print(\"Punto de acceso creado. SSID: Mi_Punto_de_Acceso\") En este ejemplo, se crea un punto de acceso con el SSID 'Mi_Punto_de_Acceso' y la contrase\u00f1a 'mi_contrase\u00f1a' . Otros dispositivos podr\u00e1n conectarse a este punto de acceso utilizando las credenciales proporcionadas.","title":"Creaci\u00f3n de Redes Ad-Hoc"},{"location":"networks/#uso-de-contrasenas-yo-seguridad","text":"Es recomendable utilizar ficheros externos con la configuraci\u00f3n de nuestro SSID y contrase\u00f1as para evitar exponer esta informaci\u00f3n sensible en el c\u00f3digo fuente. De esta manera, podemos mantener nuestras credenciales seguras y facilitar la gesti\u00f3n de m\u00faltiples configuraciones de red. Veamos un ejemplo: # archivo config.py SSID = 'TU_SSID' PASSWORD = 'TU_CONTRASE\u00d1A' # archivo main.py import network from config import SSID, PASSWORD import time # Crear una instancia de la interfaz Wi-Fi wifi = network.WLAN(network.STA_IF) # Activar la interfaz Wi-Fi wifi.active(True) # Conectarse a la red Wi-Fi wifi.connect(SSID, PASSWORD) while not wifi.isconnected(): time.sleep(1) print(\"Conectado a la red Wi-Fi:\", wifi.ifconfig()) En este ejemplo, las credenciales de la red Wi-Fi se almacenan en un archivo separado llamado config.py , lo que ayuda a mantener el c\u00f3digo m\u00e1s limpio y seguro.","title":"Uso de Contrase\u00f1as y/o Seguridad"},{"location":"references/","text":"Referencias Documentaci\u00f3n MicroPython Curso MicroPython Python Canarias Documentaci\u00f3n Raspberry Pi Pico Recursos Sobre MicroPython Esquema Blink y Ejemplos","title":"Recursos"},{"location":"references/#referencias","text":"Documentaci\u00f3n MicroPython Curso MicroPython Python Canarias Documentaci\u00f3n Raspberry Pi Pico Recursos Sobre MicroPython Esquema Blink y Ejemplos","title":"Referencias"},{"location":"sensors/","text":"Sensores Y Actuadores En esta secci\u00f3n se describen los diferentes sensores y actuadores que pueden ser utilizados en el sistema. Cada uno de ellos tiene caracter\u00edsticas espec\u00edficas que permiten su integraci\u00f3n y funcionamiento adecuado dentro del entorno. Sensores Los sensores son dispositivos que detectan cambios en el entorno f\u00edsico y convierten esa informaci\u00f3n en se\u00f1ales el\u00e9ctricas que pueden ser interpretadas por el sistema. Algunos ejemplos comunes de sensores incluyen: Sensores de temperatura Sensores de humedad Sensores de luz Sensores de proximidad Sensores de presi\u00f3n En este documento, vamos a ver algunos ejemplos de c\u00f3mo utilizar estos sensores con entradas anal\u00f3gicas y digitales. Sensor de temperatura y Humedad DHT11 El DHT11 es un sensor digital que mide la temperatura y la humedad ambiental. Para utilizarlo, se necesita una librer\u00eda espec\u00edfica que facilite la comunicaci\u00f3n con el sensor. NOTA : Puede encontrarse una versi\u00f3n con 3 pines. El funcionamiento es el mismo. Solo cambia la forma de conectarlo. Veamos como utilizar este sensor en nuestro dispositivo. Para ello, utilizamos la clase DHT11 de la librer\u00eda dht . Veamos un ejemplo de conexi\u00f3n del sensor DHT11; para ello necesitamos: 1 Sensor DHT11 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para leer los valores de temperatura y humedad del sensor DHT11: import dht from machine import Pin import time # Configurar el pin donde est\u00e1 conectado el DHT11 dht_pin = Pin(4) # Cambia el n\u00famero del pin seg\u00fan tu conexi\u00f3n sensor = dht.DHT11(dht_pin) while True: try: sensor.measure() # Realizar la medici\u00f3n temperature = sensor.temperature() # Obtener la temperatura humidity = sensor.humidity() # Obtener la humedad print(\"Temperatura: {}\u00b0C Humedad: {}%\".format(temperature, humidity)) except OSError as e: print(\"Error al leer el sensor:\", e) time.sleep(2) # Esperar 2 segundos antes de la siguiente lectura Este c\u00f3digo configura el pin donde est\u00e1 conectado el sensor DHT11, realiza mediciones peri\u00f3dicas y muestra los valores de temperatura y humedad en la consola. Aseg\u00farate de conectar correctamente el sensor al pin especificado en el c\u00f3digo. Sensor de ultrasonidos HC-SR04 El HC-SR04 es un sensor de ultrasonidos que se utiliza para medir distancias. Funciona enviando un pulso ultras\u00f3nico y midiendo el tiempo que tarda en regresar despu\u00e9s de rebotar en un objeto. Para utilizar el HC-SR04, necesitamos dos pines: uno para el disparo (trigger) y otro para la recepci\u00f3n (echo). Vamos a realizar un montaje simple para medir distancias utilizando este sensor. Para este ejemplo, necesitaremos los siguientes componentes: 1 Sensor HC-SR04 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para medir la distancia utilizando el sensor HC-SR04: from machine import Pin, time_pulse_us import time trigger_pin = Pin(12, Pin.OUT) # Pin de disparo echo_pin = Pin(14, Pin.IN) # Pin de recepci\u00f3n def medir_distancia(): # Enviar un pulso de 10 microsegundos al pin de disparo trigger_pin.value(0) time.sleep_us(2) trigger_pin.value(1) time.sleep_us(10) trigger_pin.value(0) # Medir el tiempo del pulso en el pin de recepci\u00f3n duracion = time_pulse_us(echo_pin, 1, 30000) # Esperar hasta 30ms if duracion < 0: return -1 # Indica que no se recibi\u00f3 eco # Calcular la distancia en cent\u00edmetros distancia = (duracion / 2) / 29.1 return distancia while True: distancia = medir_distancia() if distancia != -1: print(\"Distancia: {:.2f} cm\".format(distancia)) else: print(\"No se detect\u00f3 ning\u00fan objeto\") time.sleep(1) En este c\u00f3digo, configuramos los pines de disparo y recepci\u00f3n, enviamos un pulso ultras\u00f3nico y medimos el tiempo que tarda en regresar. Luego, calculamos la distancia en cent\u00edmetros y la mostramos en la consola. Sensor de sonido KY-037 El KY-037 es un sensor de sonido que puede detectar niveles de sonido en el entorno. Este sensor tiene una salida anal\u00f3gica que var\u00eda seg\u00fan la intensidad del sonido captado. Para utilizar el KY-037, conectamos su salida anal\u00f3gica a un pin ADC del microcontrolador. Vamos a realizar un ejemplo, para ello necesitaremos los siguientes componentes: 1 Sensor KY-037 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para leer los valores del sensor KY-037: from machine import ADC import time pin_number = 33 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando # Configurar el pin ADC adc = ADC(pin_number) while True: # Leer el valor anal\u00f3gico value = adc.read() print(\"Nivel de sonido:\", value) time.sleep(1) En este c\u00f3digo, configuramos el pin ADC donde est\u00e1 conectado el sensor KY-037 y leemos peri\u00f3dicamente los valores anal\u00f3gicos que representan el nivel de sonido. Estos valores se imprimen en la consola cada segundo. Como habr\u00e1s podido observar, hay un pin extra que es digital. Este pin se usa como un umbral para activar una salida digital cuando el nivel de sonido supera cierto valor. Si deseas utilizar esta funcionalidad, puedes conectar este pin a un pin digital del microcontrolador y leer su estado de manera similar a como se hace con un bot\u00f3n en la secci\u00f3n de entradas digitales. Actuadores Los actuadores son dispositivos que reciben se\u00f1ales el\u00e9ctricas del sistema y realizan una acci\u00f3n f\u00edsica en el entorno. Algunos ejemplos comunes de actuadores incluyen: Motores Servomotores Rel\u00e9s Zumbadores Ejemplo: Control de un Zumbador Para este ejemplo, necesitaremos los siguientes componentes: 1 Zumbador (buzzer) Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para hacer sonar el zumbador: from machine import Pin import time pin_number = 15 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando buzzer = Pin(pin_number, Pin.OUT) while True: buzzer.value(1) # Activar el zumbador time.sleep(0.5) # Sonar durante 0.5 segundos buzzer.value(0) # Desactivar el zumbador time.sleep(0.5) # Esperar 0.5 segundos En este c\u00f3digo, configuramos el pin donde est\u00e1 conectado el zumbador y lo activamos y desactivamos peri\u00f3dicamente para crear un sonido intermitente. Se puede usar una salida PWM para controlar el tono del zumbador.","title":"Sensores/Actuadores"},{"location":"sensors/#sensores-y-actuadores","text":"En esta secci\u00f3n se describen los diferentes sensores y actuadores que pueden ser utilizados en el sistema. Cada uno de ellos tiene caracter\u00edsticas espec\u00edficas que permiten su integraci\u00f3n y funcionamiento adecuado dentro del entorno.","title":"Sensores Y Actuadores"},{"location":"sensors/#sensores","text":"Los sensores son dispositivos que detectan cambios en el entorno f\u00edsico y convierten esa informaci\u00f3n en se\u00f1ales el\u00e9ctricas que pueden ser interpretadas por el sistema. Algunos ejemplos comunes de sensores incluyen: Sensores de temperatura Sensores de humedad Sensores de luz Sensores de proximidad Sensores de presi\u00f3n En este documento, vamos a ver algunos ejemplos de c\u00f3mo utilizar estos sensores con entradas anal\u00f3gicas y digitales.","title":"Sensores"},{"location":"sensors/#sensor-de-temperatura-y-humedad-dht11","text":"El DHT11 es un sensor digital que mide la temperatura y la humedad ambiental. Para utilizarlo, se necesita una librer\u00eda espec\u00edfica que facilite la comunicaci\u00f3n con el sensor. NOTA : Puede encontrarse una versi\u00f3n con 3 pines. El funcionamiento es el mismo. Solo cambia la forma de conectarlo. Veamos como utilizar este sensor en nuestro dispositivo. Para ello, utilizamos la clase DHT11 de la librer\u00eda dht . Veamos un ejemplo de conexi\u00f3n del sensor DHT11; para ello necesitamos: 1 Sensor DHT11 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para leer los valores de temperatura y humedad del sensor DHT11: import dht from machine import Pin import time # Configurar el pin donde est\u00e1 conectado el DHT11 dht_pin = Pin(4) # Cambia el n\u00famero del pin seg\u00fan tu conexi\u00f3n sensor = dht.DHT11(dht_pin) while True: try: sensor.measure() # Realizar la medici\u00f3n temperature = sensor.temperature() # Obtener la temperatura humidity = sensor.humidity() # Obtener la humedad print(\"Temperatura: {}\u00b0C Humedad: {}%\".format(temperature, humidity)) except OSError as e: print(\"Error al leer el sensor:\", e) time.sleep(2) # Esperar 2 segundos antes de la siguiente lectura Este c\u00f3digo configura el pin donde est\u00e1 conectado el sensor DHT11, realiza mediciones peri\u00f3dicas y muestra los valores de temperatura y humedad en la consola. Aseg\u00farate de conectar correctamente el sensor al pin especificado en el c\u00f3digo.","title":"Sensor de temperatura y Humedad DHT11"},{"location":"sensors/#sensor-de-ultrasonidos-hc-sr04","text":"El HC-SR04 es un sensor de ultrasonidos que se utiliza para medir distancias. Funciona enviando un pulso ultras\u00f3nico y midiendo el tiempo que tarda en regresar despu\u00e9s de rebotar en un objeto. Para utilizar el HC-SR04, necesitamos dos pines: uno para el disparo (trigger) y otro para la recepci\u00f3n (echo). Vamos a realizar un montaje simple para medir distancias utilizando este sensor. Para este ejemplo, necesitaremos los siguientes componentes: 1 Sensor HC-SR04 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para medir la distancia utilizando el sensor HC-SR04: from machine import Pin, time_pulse_us import time trigger_pin = Pin(12, Pin.OUT) # Pin de disparo echo_pin = Pin(14, Pin.IN) # Pin de recepci\u00f3n def medir_distancia(): # Enviar un pulso de 10 microsegundos al pin de disparo trigger_pin.value(0) time.sleep_us(2) trigger_pin.value(1) time.sleep_us(10) trigger_pin.value(0) # Medir el tiempo del pulso en el pin de recepci\u00f3n duracion = time_pulse_us(echo_pin, 1, 30000) # Esperar hasta 30ms if duracion < 0: return -1 # Indica que no se recibi\u00f3 eco # Calcular la distancia en cent\u00edmetros distancia = (duracion / 2) / 29.1 return distancia while True: distancia = medir_distancia() if distancia != -1: print(\"Distancia: {:.2f} cm\".format(distancia)) else: print(\"No se detect\u00f3 ning\u00fan objeto\") time.sleep(1) En este c\u00f3digo, configuramos los pines de disparo y recepci\u00f3n, enviamos un pulso ultras\u00f3nico y medimos el tiempo que tarda en regresar. Luego, calculamos la distancia en cent\u00edmetros y la mostramos en la consola.","title":"Sensor de ultrasonidos HC-SR04"},{"location":"sensors/#sensor-de-sonido-ky-037","text":"El KY-037 es un sensor de sonido que puede detectar niveles de sonido en el entorno. Este sensor tiene una salida anal\u00f3gica que var\u00eda seg\u00fan la intensidad del sonido captado. Para utilizar el KY-037, conectamos su salida anal\u00f3gica a un pin ADC del microcontrolador. Vamos a realizar un ejemplo, para ello necesitaremos los siguientes componentes: 1 Sensor KY-037 Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para leer los valores del sensor KY-037: from machine import ADC import time pin_number = 33 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando # Configurar el pin ADC adc = ADC(pin_number) while True: # Leer el valor anal\u00f3gico value = adc.read() print(\"Nivel de sonido:\", value) time.sleep(1) En este c\u00f3digo, configuramos el pin ADC donde est\u00e1 conectado el sensor KY-037 y leemos peri\u00f3dicamente los valores anal\u00f3gicos que representan el nivel de sonido. Estos valores se imprimen en la consola cada segundo. Como habr\u00e1s podido observar, hay un pin extra que es digital. Este pin se usa como un umbral para activar una salida digital cuando el nivel de sonido supera cierto valor. Si deseas utilizar esta funcionalidad, puedes conectar este pin a un pin digital del microcontrolador y leer su estado de manera similar a como se hace con un bot\u00f3n en la secci\u00f3n de entradas digitales.","title":"Sensor de sonido KY-037"},{"location":"sensors/#actuadores","text":"Los actuadores son dispositivos que reciben se\u00f1ales el\u00e9ctricas del sistema y realizan una acci\u00f3n f\u00edsica en el entorno. Algunos ejemplos comunes de actuadores incluyen: Motores Servomotores Rel\u00e9s Zumbadores","title":"Actuadores"},{"location":"sensors/#ejemplo-control-de-un-zumbador","text":"Para este ejemplo, necesitaremos los siguientes componentes: 1 Zumbador (buzzer) Cables de conexi\u00f3n Protoboard El montaje se realizar\u00e1 de la siguiente manera: A continuaci\u00f3n, se muestra un ejemplo de c\u00f3digo para hacer sonar el zumbador: from machine import Pin import time pin_number = 15 # Cambia esto al n\u00famero de pin que est\u00e1s utilizando buzzer = Pin(pin_number, Pin.OUT) while True: buzzer.value(1) # Activar el zumbador time.sleep(0.5) # Sonar durante 0.5 segundos buzzer.value(0) # Desactivar el zumbador time.sleep(0.5) # Esperar 0.5 segundos En este c\u00f3digo, configuramos el pin donde est\u00e1 conectado el zumbador y lo activamos y desactivamos peri\u00f3dicamente para crear un sonido intermitente. Se puede usar una salida PWM para controlar el tono del zumbador.","title":"Ejemplo: Control de un Zumbador"},{"location":"simulator/","text":"Simulador MicroPython Para poder practicar y aprender MicroPython sin necesidad de tener una placa f\u00edsica, podemos utilizar un simulador online llamado Wokwi . Este simulador nos permite crear proyectos con placas como ESP32 y Raspberry Pi Pico, y programarlas utilizando MicroPython. En la imagen superior podemos ver la interfaz del simulador Wokwi. A la derecha tenemos el \u00e1rea de dise\u00f1o, donde podemos a\u00f1adir componentes electr\u00f3nicos como LEDs, resistencias, sensores, etc. En la izquierda tenemos el \u00e1rea de c\u00f3digo, donde escribiremos nuestro programa en MicroPython. A la derecha tenemos la consola, donde podremos ver la salida de nuestro programa y cualquier mensaje de error. Crear un Proyecto en Wokwi En primer lugar, entraremos en la siguiente direcci\u00f3n: https://wokwi.com/projects/new/ Seleccionaremos nuestra placa (ESP32 o Raspberry Pi Pico) y el tipo de proyecto (Arduino o MicroPython). En este caso, seleccionaremos MicroPython. Una vez creado el proyecto, podremos empezar a a\u00f1adir componentes electr\u00f3nicos al \u00e1rea de dise\u00f1o. Para ello, utilizaremos el men\u00fa de la izquierda, donde podremos buscar y seleccionar los componentes que necesitamos. Vamos a realizar un montaje sencillo para encender y apagar un LED utilizando MicroPython. A\u00f1adiremos un LED y una resistencia al \u00e1rea de dise\u00f1o, conect\u00e1ndolos a un pin GPIO de la placa. Mostramos en la siguiente imagen el montaje realizado: NOTA : Para rotar un elemento pulsar R y para voltearlo P. Es importante tener en cuenta que la resistencia debe estar en serie con el LED para limitar la corriente que pasa a trav\u00e9s de \u00e9l y evitar que se queme. En este caso, utilizaremos una resistencia de 220 ohmios. Para cambiar el valor de la resistencia, haremos clic sobre ella y en el men\u00fa de propiedades a la derecha, cambiaremos el valor a 220. Una vez hecho esto, escribiremos el siguiente c\u00f3digo en el \u00e1rea de c\u00f3digo: from machine import Pin from time import sleep ledpin=19 pin = Pin(ledpin, Pin.OUT) while True: pin.value(1) sleep(1) pin.value(0) sleep(1) Una vez escrito el c\u00f3digo, podremos ejecutar el proyecto haciendo clic en el bot\u00f3n \"Run\" (Bot\u00f3n verde con flecha) en la parte superior de la pantalla. Veremos c\u00f3mo el LED se enciende y apaga cada segundo, tal como hemos programado. Este es un ejemplo sencillo de c\u00f3mo utilizar el simulador Wokwi para aprender y practicar MicroPython sin necesidad de tener una placa f\u00edsica. Podemos experimentar con diferentes componentes y programas para ampliar nuestros conocimientos en MicroPython y electr\u00f3nica. En las siguientes p\u00e1ginas vamos a centrarnos en utilizar los diferentes dispositivos y elementos ya sea de forma f\u00edsica o utilizando este simulador online.","title":"Simulador MicroPython"},{"location":"simulator/#simulador-micropython","text":"Para poder practicar y aprender MicroPython sin necesidad de tener una placa f\u00edsica, podemos utilizar un simulador online llamado Wokwi . Este simulador nos permite crear proyectos con placas como ESP32 y Raspberry Pi Pico, y programarlas utilizando MicroPython. En la imagen superior podemos ver la interfaz del simulador Wokwi. A la derecha tenemos el \u00e1rea de dise\u00f1o, donde podemos a\u00f1adir componentes electr\u00f3nicos como LEDs, resistencias, sensores, etc. En la izquierda tenemos el \u00e1rea de c\u00f3digo, donde escribiremos nuestro programa en MicroPython. A la derecha tenemos la consola, donde podremos ver la salida de nuestro programa y cualquier mensaje de error.","title":"Simulador MicroPython"},{"location":"simulator/#crear-un-proyecto-en-wokwi","text":"En primer lugar, entraremos en la siguiente direcci\u00f3n: https://wokwi.com/projects/new/ Seleccionaremos nuestra placa (ESP32 o Raspberry Pi Pico) y el tipo de proyecto (Arduino o MicroPython). En este caso, seleccionaremos MicroPython. Una vez creado el proyecto, podremos empezar a a\u00f1adir componentes electr\u00f3nicos al \u00e1rea de dise\u00f1o. Para ello, utilizaremos el men\u00fa de la izquierda, donde podremos buscar y seleccionar los componentes que necesitamos. Vamos a realizar un montaje sencillo para encender y apagar un LED utilizando MicroPython. A\u00f1adiremos un LED y una resistencia al \u00e1rea de dise\u00f1o, conect\u00e1ndolos a un pin GPIO de la placa. Mostramos en la siguiente imagen el montaje realizado: NOTA : Para rotar un elemento pulsar R y para voltearlo P. Es importante tener en cuenta que la resistencia debe estar en serie con el LED para limitar la corriente que pasa a trav\u00e9s de \u00e9l y evitar que se queme. En este caso, utilizaremos una resistencia de 220 ohmios. Para cambiar el valor de la resistencia, haremos clic sobre ella y en el men\u00fa de propiedades a la derecha, cambiaremos el valor a 220. Una vez hecho esto, escribiremos el siguiente c\u00f3digo en el \u00e1rea de c\u00f3digo: from machine import Pin from time import sleep ledpin=19 pin = Pin(ledpin, Pin.OUT) while True: pin.value(1) sleep(1) pin.value(0) sleep(1) Una vez escrito el c\u00f3digo, podremos ejecutar el proyecto haciendo clic en el bot\u00f3n \"Run\" (Bot\u00f3n verde con flecha) en la parte superior de la pantalla. Veremos c\u00f3mo el LED se enciende y apaga cada segundo, tal como hemos programado. Este es un ejemplo sencillo de c\u00f3mo utilizar el simulador Wokwi para aprender y practicar MicroPython sin necesidad de tener una placa f\u00edsica. Podemos experimentar con diferentes componentes y programas para ampliar nuestros conocimientos en MicroPython y electr\u00f3nica. En las siguientes p\u00e1ginas vamos a centrarnos en utilizar los diferentes dispositivos y elementos ya sea de forma f\u00edsica o utilizando este simulador online.","title":"Crear un Proyecto en Wokwi"}]}